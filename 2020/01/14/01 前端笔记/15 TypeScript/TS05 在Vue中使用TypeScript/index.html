<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo-new.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"duola8789.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="使用Vue2.6 + TypeScript3.5.3创建了一个项目，下面是我的一些经验和笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="TS05 在Vue中使用TypeScript">
<meta property="og:url" content="https://duola8789.github.io/2020/01/14/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/15%20TypeScript/TS05%20%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/index.html">
<meta property="og:site_name" content="不负时光">
<meta property="og:description" content="使用Vue2.6 + TypeScript3.5.3创建了一个项目，下面是我的一些经验和笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.oldzhou.cn/FkyWESp1wooznoBLa1K9wdS6MhXM">
<meta property="article:published_time" content="2020-01-14T12:00:40.000Z">
<meta property="article:modified_time" content="2020-06-22T10:22:19.000Z">
<meta property="article:author" content="多啦大薯片">
<meta property="article:tag" content="Vue">
<meta property="article:tag" content="TypeScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.oldzhou.cn/FkyWESp1wooznoBLa1K9wdS6MhXM">


<link rel="canonical" href="https://duola8789.github.io/2020/01/14/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/15%20TypeScript/TS05%20%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://duola8789.github.io/2020/01/14/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/15%20TypeScript/TS05%20%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/","path":"2020/01/14/01 前端笔记/15 TypeScript/TS05 在Vue中使用TypeScript/","title":"TS05 在Vue中使用TypeScript"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>TS05 在Vue中使用TypeScript | 不负时光</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?383801e819a170224708308b7b4411a5"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">不负时光</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">少年回头望，笑我还不快跟上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="http://www.oldzhou.cn/pages/page1.html" rel="section" target="_blank"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Vue-CLI%E6%94%AF%E6%8C%81"><span class="nav-number">1.</span> <span class="nav-text">1 Vue-CLI支持</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%94%B9%E9%80%A0%E7%BB%84%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">2 改造组件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-%E7%BB%84%E4%BB%B6%E5%B1%9E%E6%80%A7%E9%A1%BA%E5%BA%8F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 组件属性顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-%E7%9B%B8%E5%85%B3API"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 相关API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Data"><span class="nav-number">2.2.1.</span> <span class="nav-text">（1）Data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7"><span class="nav-number">2.2.2.</span> <span class="nav-text">（2）计算属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89-Prop"><span class="nav-number">2.2.3.</span> <span class="nav-text">（3）@Prop</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89-PropSync"><span class="nav-number">2.2.4.</span> <span class="nav-text">（4）@PropSync</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-number">2.2.5.</span> <span class="nav-text">（5）定义方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%886%EF%BC%89-Watch"><span class="nav-number">2.2.6.</span> <span class="nav-text">（6）@Watch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%887%EF%BC%89-Emit"><span class="nav-number">2.2.7.</span> <span class="nav-text">（7）@Emit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%888%EF%BC%89-Model"><span class="nav-number">2.2.8.</span> <span class="nav-text">（8）@Model</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%889%EF%BC%89-Ref"><span class="nav-number">2.2.9.</span> <span class="nav-text">（9）@Ref</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8810%EF%BC%89Mixins"><span class="nav-number">2.2.10.</span> <span class="nav-text">（10）Mixins</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%8811%EF%BC%89-Inject-x2F-Provide"><span class="nav-number">2.2.11.</span> <span class="nav-text">（11）@Inject&#x2F;@Provide</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E6%94%B9%E9%80%A0Vue-Router"><span class="nav-number">3.</span> <span class="nav-text">3 改造Vue Router</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%94%B9%E9%80%A0Vuex"><span class="nav-number">4.</span> <span class="nav-text">4 改造Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E4%BD%BF%E7%94%A8vue-class-component"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 使用vue-class-component</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E4%BD%BF%E7%94%A8vuex-class"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 使用vuex-class</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-%E4%BD%BF%E7%94%A8vuex-module-decorators"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 使用vuex-module-decorators</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-%E6%9C%80%E7%BB%88%E9%80%89%E6%8B%A9vuex-class"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 最终选择vuex-class</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E7%9B%B8%E5%85%B3%E5%AE%9E%E8%B7%B5"><span class="nav-number">5.</span> <span class="nav-text">5 相关实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-TypeScript%E7%B1%BB%E5%9E%8B%E6%A0%A1%E9%AA%8C"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 TypeScript类型校验</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-Lint%E5%B7%A5%E5%85%B7"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 Lint工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89ESLint"><span class="nav-number">5.2.1.</span> <span class="nav-text">（1）ESLint</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Prettier"><span class="nav-number">5.2.2.</span> <span class="nav-text">（2）Prettier</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89StyleLint"><span class="nav-number">5.2.3.</span> <span class="nav-text">（3）StyleLint</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 目录组织</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89types-ts%E6%96%87%E4%BB%B6"><span class="nav-number">5.3.1.</span> <span class="nav-text">（1）types.ts文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%9B%AE%E5%BD%95%E7%BB%84%E7%BB%87"><span class="nav-number">5.3.2.</span> <span class="nav-text">（2）目录组织</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-%E5%91%BD%E5%90%8D"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 命名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E7%9B%AE%E5%BD%95%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">5.4.1.</span> <span class="nav-text">（1）目录的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E7%BB%84%E4%BB%B6%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">5.4.2.</span> <span class="nav-text">（2）组件的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%8F%98%E9%87%8F%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">5.4.3.</span> <span class="nav-text">（3）变量的命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%91%BD%E5%90%8D"><span class="nav-number">5.4.4.</span> <span class="nav-text">（4）接口的命名</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-%E8%B7%AF%E7%94%B1"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 路由</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89%E6%8C%89%E6%A8%A1%E5%9D%97%E7%BB%84%E7%BB%87%E8%B7%AF%E7%94%B1"><span class="nav-number">5.6.1.</span> <span class="nav-text">（1）按模块组织路由</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E8%B7%AF%E7%94%B1%E6%B1%87%E6%80%BB"><span class="nav-number">5.6.2.</span> <span class="nav-text">（2）路由汇总</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E5%AF%BC%E8%88%AA"><span class="nav-number">5.6.3.</span> <span class="nav-text">（3）导航</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-Vuex"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 Vuex</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Store%E7%9B%AE%E5%BD%95%E5%88%92%E5%88%86"><span class="nav-number">5.7.1.</span> <span class="nav-text">（1）Store目录划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89Store%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.7.2.</span> <span class="nav-text">（2）Store的实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE%E9%9C%80%E8%A6%81%E5%AD%98%E5%88%B0Store%E4%B8%AD"><span class="nav-number">5.7.3.</span> <span class="nav-text">（3）什么数据需要存到Store中</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E7%BC%93%E5%AD%98"><span class="nav-number">5.7.4.</span> <span class="nav-text">（4）缓存</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-number">5.8.</span> <span class="nav-text">5.8 网络请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Axios%E7%9A%84%E5%B0%81%E8%A3%85"><span class="nav-number">5.8.1.</span> <span class="nav-text">（1）Axios的封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E5%85%A8%E5%B1%80Loading"><span class="nav-number">5.8.2.</span> <span class="nav-text">（2）全局Loading</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89Mock%E6%95%B0%E6%8D%AE"><span class="nav-number">5.8.3.</span> <span class="nav-text">（3）Mock数据</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-9-%E6%A0%B7%E5%BC%8F"><span class="nav-number">5.9.</span> <span class="nav-text">5.9 样式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89UI%E7%BB%84%E4%BB%B6"><span class="nav-number">5.9.1.</span> <span class="nav-text">（1）UI组件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%A0%B7%E5%BC%8F%E8%A7%84%E8%8C%83"><span class="nav-number">5.9.2.</span> <span class="nav-text">（2）样式规范</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89%E8%87%AA%E5%8A%A8%E5%AF%BC%E5%85%A5%E5%85%A8%E5%B1%80%E6%A0%B7%E5%BC%8F%E5%8F%98%E9%87%8F"><span class="nav-number">5.9.3.</span> <span class="nav-text">（3）自动导入全局样式变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-10-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8C%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC"><span class="nav-number">5.10.</span> <span class="nav-text">5.10 环境变量和构建脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-11-Code-Reivew"><span class="nav-number">5.11.</span> <span class="nav-text">5.11 Code Reivew</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-12-Todo"><span class="nav-number">5.12.</span> <span class="nav-text">5.12 Todo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%881%EF%BC%89Axios-Vuex%E7%9A%84%E5%85%A8%E5%B1%80%E7%BC%93%E5%AD%98"><span class="nav-number">5.12.1.</span> <span class="nav-text">（1）Axios + Vuex的全局缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%882%EF%BC%89%E6%8E%A5%E5%8F%A3%E8%B6%85%E6%97%B6%E8%87%AA%E5%8A%A8%E9%87%8D%E8%AF%95"><span class="nav-number">5.12.2.</span> <span class="nav-text">（2）接口超时自动重试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%883%EF%BC%89WebP%E5%9B%BE%E7%89%87%E5%BC%95%E5%85%A5"><span class="nav-number">5.12.3.</span> <span class="nav-text">（3）WebP图片引入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%884%EF%BC%89%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7%E5%92%8C%E4%B8%8A%E6%8A%A5"><span class="nav-number">5.12.4.</span> <span class="nav-text">（4）异常监控和上报</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%EF%BC%885%EF%BC%89%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9"><span class="nav-number">5.12.5.</span> <span class="nav-text">（5）图片压缩</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-CLI%E5%B7%A5%E5%85%B7"><span class="nav-number">6.</span> <span class="nav-text">6 CLI工具</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#7-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">7.</span> <span class="nav-text">7 常见问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">8.</span> <span class="nav-text">参考</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="多啦大薯片"
      src="/images/avatar3.png">
  <p class="site-author-name" itemprop="name">多啦大薯片</p>
  <div class="site-description" itemprop="description">欲买桂花同载酒，终不似，少年游</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">212</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">281</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/duola8789" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;duola8789" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:duola8789@126.com" title="E-Mail → mailto:duola8789@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/zhouhaozhouhao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;zhouhaozhouhao" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/aisheishei2011" title="Douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;aisheishei2011" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i>Douban</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://duola8789.github.io/2020/01/14/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/15%20TypeScript/TS05%20%E5%9C%A8Vue%E4%B8%AD%E4%BD%BF%E7%94%A8TypeScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar3.png">
      <meta itemprop="name" content="多啦大薯片">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不负时光">
      <meta itemprop="description" content="欲买桂花同载酒，终不似，少年游">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="TS05 在Vue中使用TypeScript | 不负时光">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          TS05 在Vue中使用TypeScript
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2020-01-14 20:00:40" itemprop="dateCreated datePublished" datetime="2020-01-14T20:00:40+08:00">2020-01-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2020-06-22 18:22:19" itemprop="dateModified" datetime="2020-06-22T18:22:19+08:00">2020-06-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/TypeScript/" itemprop="url" rel="index"><span itemprop="name">TypeScript</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>使用Vue2.6 + TypeScript3.5.3创建了一个项目，下面是我的一些经验和笔记。</p>
<span id="more"></span>

<p>[toc]</p>
<blockquote>
<p>（2020.01.07）其中有一些最佳实践可能会随着项目的逐渐迭代进行调整，请自行辨别可行性</p>
</blockquote>
<h1 id="1-Vue-CLI支持"><a href="#1-Vue-CLI支持" class="headerlink" title="1 Vue-CLI支持"></a>1 Vue-CLI支持</h1><p>Vue-CLI内建了TypeScript工具支持，在新建项目时可以选择使用TypeScript扩展，包括了针对Vue Core的官方类型声明，还包括了Vue Router和Vuex提供了相应的声明文件</p>
<p>使用Vue-CLI会自动创建<code>tsconfig.json</code>文件，基本上使用默认的配置文件就可以满足要求。</p>
<h1 id="2-改造组件"><a href="#2-改造组件" class="headerlink" title="2 改造组件"></a>2 改造组件</h1><p>使用TypeScript编写Vue单文件组件有两种方式，一种是通过<code>Vue.extend()</code>方法，另一种是基于类的Vue组件（在使用Vue-CLI创建项目的时候可以选择），我选择使用了后者，可以提供更优雅、更类似于JSX的书写体验。</p>
<p>需要安装<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-class-component">vue-class-component</a>用来将Vue组件改写为基于Class的形式，也可以选择使用<a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a>，后者依赖于前者，而且提供了额外的装饰符，让编写更简单。</p>
<p>使用的时候，将原来导出的类型由对象改为了Class，并且使用<code>@Component</code>装饰符，如果有要引入的其他子组件，也放到<code>@Component</code>中。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">Child</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloVue</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// 组件内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，虽然使用了<code>export default</code>，但是Class的名字还是最好准确定义，这样便于IDE和Lint工具进行追踪、提示。</p>
<h2 id="2-1-组件属性顺序"><a href="#2-1-组件属性顺序" class="headerlink" title="2.1 组件属性顺序"></a>2.1 组件属性顺序</h2><p>没有发现Lint和Prettier规则来强制规定组件内的属性顺序，所以约定好一个书写顺序，作为最佳实践</p>
<p>要注意，组件引用、Mixin和Filters都放到了组件外部。总体的顺序分为了三部分：</p>
<ol>
<li>数据（ Inject → Prop → Data → Computed  → Model → Vuex-State → Vuex-Getter → Proivde ）</li>
<li>方法（Vuex-Mutation → Vuex-Action → Methods → Watch）</li>
<li>钩子函数（生命周期钩子 → 路由钩子）</li>
</ol>
<p>完整的组件如下，具体写法后面单独列出来（不包含Mixin）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span>(&#123; <span class="attr">components</span>: &#123; <span class="title class_">Child</span> &#125; &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// 数据 (Inject → Prop→ Computed → Model → Vuex-State → Vuex-Getter → Proivde)</span></span><br><span class="line">  <span class="comment">// 使用祖先组件注入的数据</span></span><br><span class="line">  @<span class="title class_">Inject</span>() readonly value1!: string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件的 Data</span></span><br><span class="line">  value = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父组件传入 Prop</span></span><br><span class="line">  @<span class="title class_">Prop</span>(<span class="title class_">Number</span>) readonly value2!: number;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算属性</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">value3</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">value1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 定义 组件的 Model 属性</span></span><br><span class="line">  @<span class="title class_">Model</span>(<span class="string">&#x27;change&#x27;</span>, &#123; <span class="attr">type</span>: <span class="title class_">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;) checked!: boolean;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Vuex Store 中定义的 state，作为计算属性定义在组件内</span></span><br><span class="line">  @<span class="title class_">State</span> value4!: string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Vuex Store 中定义的 getter，作为计算属性定义在组件内</span></span><br><span class="line">  @<span class="title class_">Getter</span> value5!: string;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为子孙组件提供数据</span></span><br><span class="line">  @<span class="title class_">Provide</span>() root = <span class="string">&#x27;Root&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ----------------------------------------------- */</span></span><br><span class="line">  <span class="comment">// 方法 (Vuex-Mutation → Vuex-Action → Methods → Watch)</span></span><br><span class="line">  <span class="comment">// Vuex Store 中定义的 Mutation，作为方法定义在组件内</span></span><br><span class="line">  @<span class="title class_">Mutation</span>(<span class="variable constant_">UPDATE_TITLE_MUTATION</span>) updateTitle!: <span class="function">(<span class="params">payload: &#123; title: string &#125;</span>) =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Vuex Store 中定义的 Action，作为方法定义在组件内</span></span><br><span class="line">  @<span class="title class_">Action</span>(<span class="variable constant_">UPDATE_TITLE_ACTION</span>) updateTitleSync!: <span class="function">() =&gt;</span> <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件内的 Method</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">foo</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">isCollapse</span> ? <span class="string">&#x27;collapsed-menu&#x27;</span> : <span class="string">&#x27;expanded-menu&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件内的 Watch</span></span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;value1&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">onDataChanged</span>(<span class="attr">newVal</span>: string, <span class="attr">oldVal</span>: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">foo</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* ----------------------------------------------- */</span></span><br><span class="line">  <span class="comment">// 钩子函数 (生命周期钩子 → 路由钩子)</span></span><br><span class="line">  <span class="title function_">beforeCreated</span>()</span><br><span class="line"></span><br><span class="line">  <span class="title function_">created</span>()</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeMount</span>()</span><br><span class="line"></span><br><span class="line">  <span class="title function_">mounted</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeUpdate</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">updated</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">activated</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">deactivated</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeDetory</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">destoryed</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">errorCaptured</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeRouteEnter</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeRouteUpdate</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">beforeRouteLeave</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-相关API"><a href="#2-2-相关API" class="headerlink" title="2.2 相关API"></a>2.2 相关API</h2><h3 id="（1）Data"><a href="#（1）Data" class="headerlink" title="（1）Data"></a>（1）Data</h3><p>直接在Class定义即可（实际上就是<a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/class#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E6%96%B0%E5%86%99%E6%B3%95">Class的新语法</a>，与在Class的<code>constructor</code>中定义相同）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Prop</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">msg</span>: number = <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（2）计算属性"><a href="#（2）计算属性" class="headerlink" title="（2）计算属性"></a>（2）计算属性</h3><p>计算属性采取使用<code>getter</code>的形式定义，在Class内部可以使用<code>get</code>和<code>set</code>关键字，设置某个属性的存值函数和取值函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Prop</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="attr">num</span>: number = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attr">get</span>: <span class="attr">value</span>: <span class="title function_">string</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">num</span> + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时定义<code>set</code>实现了对计算属性的赋值。</p>
<h3 id="（3）-Prop"><a href="#（3）-Prop" class="headerlink" title="（3）@Prop"></a>（3）<code>@Prop</code></h3><p><code>@Prop</code>接受的参数就是原来在Vue中<code>props</code>中传入的参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">Prop</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Prop</span>(<span class="title class_">Number</span>) readonly <span class="attr">propA</span>: number | <span class="literal">undefined</span></span><br><span class="line">  @<span class="title class_">Prop</span>(&#123; <span class="attr">default</span>: <span class="string">&#x27;default value&#x27;</span> &#125;) readonly propB!: string</span><br><span class="line">  @<span class="title class_">Prop</span>([<span class="title class_">String</span>, <span class="title class_">Boolean</span>]) readonly <span class="attr">propC</span>: string | boolean | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（4）-PropSync"><a href="#（4）-PropSync" class="headerlink" title="（4）@PropSync"></a>（4）<code>@PropSync</code></h3><p><code>@PropSync</code>与<code>Prop</code>类似，不同之处在于<code>@PropSync</code>会自动生成一个计算属性，计算属性的<code>getter</code>返回传入的Prop，计算属性的<code>setter</code>中会执行Vue中提倡的更新Prop的<code>emit:updatePropName</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Vue</span>, <span class="title class_">Component</span>, <span class="title class_">PropSync</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">YourComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">PropSync</span>(<span class="string">&#x27;name&#x27;</span>, &#123; <span class="attr">type</span>: <span class="title class_">String</span> &#125;) syncedName!: string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="title class_">String</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="attr">syncedName</span>: &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.$emit(<span class="string">&#x27;update:name&#x27;</span>, value)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>使用时需要配合<code>.sync</code>修饰符使用（即在组件上定义对应的更新方法）：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello-sync</span> <span class="attr">:my-prop.sync</span>=<span class="string">&quot;syncValue&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hello-sync</span> <span class="attr">:my-prop</span>=<span class="string">&quot;syncValue&quot;</span> @<span class="attr">update:name</span>=<span class="string">&quot;(name) =&gt; syncValue = name&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（5）定义方法"><a href="#（5）定义方法" class="headerlink" title="（5）定义方法"></a>（5）定义方法</h3><p>定义方法与Data类型，直接在Class中定义方法即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（6）-Watch"><a href="#（6）-Watch" class="headerlink" title="（6）@Watch"></a>（6）<code>@Watch</code></h3><p>使用<code>@Watch</code>定义侦听器，被装饰的函数就是侦听器执行方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Watch</span>(<span class="string">&#x27;msg&#x27;</span>, &#123; <span class="attr">immediate</span>: <span class="literal">true</span>, <span class="attr">deep</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  <span class="title function_">onMsgChanged</span>(<span class="attr">newVal</span>: string, <span class="attr">oldVal</span>: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">oldMsg</span> = oldVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（7）-Emit"><a href="#（7）-Emit" class="headerlink" title="（7）@Emit"></a>（7）<code>@Emit</code></h3><p>想要触发父组件中定义在组件实例上的方法，需要使用<code>@Emit</code>装饰符。<code>@Emit</code>接受一个参数，是要触发的事件名，如果要出发的事件名和被装饰的方法同名，那么这个参数可以省略。<code>@Emit</code>返回值就是传递给事件的参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Emit</span>()</span><br><span class="line">  <span class="title function_">sayHi</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Emit</span>(<span class="string">&#x27;go&#x27;</span>)</span><br><span class="line">  <span class="title function_">goHere</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;gogogo&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;sayHi&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">goHere</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&#x27;go&#x27;</span>, <span class="string">&#x27;gogogo&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（8）-Model"><a href="#（8）-Model" class="headerlink" title="（8）@Model"></a>（8）<code>@Model</code></h3><p>一般用来在自定义的组件上使用<code>v-model</code>，自定义组件中包含可交互元素（例如<code>&lt;input&gt;</code>或者<code>&lt;checkbox</code>），当组可交互元素绑定的值发生变化（<code>oninput</code>、<code>onchange</code>）时，会传递到父组件绑定的<code>v-model</code>属性上。</p>
<p>关于自定义组件<code>v-model</code>的介绍可以参考<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model">官方文档</a>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">el-checkbox</span> <span class="attr">:checked</span>=<span class="string">&quot;checked&quot;</span> @<span class="attr">change</span>=<span class="string">&quot;changeHandler&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span>, <span class="title class_">Model</span>, <span class="title class_">Emit</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">@<span class="title class_">Component</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloVModel</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  @<span class="title class_">Model</span>(<span class="string">&#x27;change&#x27;</span>, &#123; <span class="attr">type</span>: <span class="title class_">Boolean</span>, <span class="attr">default</span>: <span class="literal">false</span> &#125;) checked!: boolean;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  @<span class="title class_">Emit</span>(<span class="string">&#x27;change&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">changeHandler</span>(<span class="params">checked: boolean</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> checked;</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用的时候：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hello-v-model</span> <span class="attr">v-model</span>=<span class="string">&quot;componentVModel&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>自定义组件利用了<code>@Model</code>，定义了<code>checked</code>属性，并且利用了<code>@change</code>事件，当<code>checkbox</code>发生了<code>change</code>事件后，父组件中的<code>componentVModel</code>就会随之发生变化。</p>
<p>实际上<code>Modal</code>和<code>.sync</code>修饰符都是Vue为了方便子组件同步数据到父组件而实现的语法糖。</p>
<h3 id="（9）-Ref"><a href="#（9）-Ref" class="headerlink" title="（9）@Ref"></a>（9）<code>@Ref</code></h3><p>当使用<code>ref</code>属性标记一个子组件或者HTML元素的时候，需要使用<code>@Ref</code>修饰符来找到标记的组件或元素。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;someRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hello-ref</span> <span class="attr">ref</span>=<span class="string">&quot;hello&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果我们需要获取<code>ref</code>引用时：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span>, <span class="title class_">Watch</span>, <span class="title class_">Ref</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HelloRef</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/baseKnowledge/hello-vue/components/HelloRef.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(&#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    <span class="title class_">HelloChild</span>,</span><br><span class="line">    <span class="title class_">HelloSync</span>,</span><br><span class="line">    <span class="title class_">HelloVModel</span>,</span><br><span class="line">    <span class="title class_">HelloRef</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">HelloVue</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Ref</span>() readonly hello!: <span class="title class_">HelloRef</span>;</span><br><span class="line">  @<span class="title class_">Ref</span>() readonly someRef!: <span class="title class_">HTMLDivElement</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>@Ref</code>后面跟的参数就是对应的<code>ref</code>的值，需要为其指定类型，如果是原生的元素，可以使用对应的与内置原生元素类型，如果是自定义组件，那么可以将引入的组件作为类型</p>
<p>如果在<code>HelloRef</code>中定义了一个<code>notify</code>方法，我们就可以按照如下调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">hello</span>.<span class="title function_">notify</span>()</span><br></pre></td></tr></table></figure>

<p>但是现在应该是Vue-Cli内置的Vue类型系统有一个Bug，始终会报如下的错误：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error:(141, 16) TS2551: Property <span class="string">&#x27;notify&#x27;</span> does not exist on <span class="built_in">type</span> <span class="string">&#x27;Vue&#x27;</span>. Did you mean <span class="string">&#x27;$notify&#x27;</span>?</span><br></pre></td></tr></table></figure>

<p>我的处理方法时，在为<code>hello</code>定义类型时，手写类型，传入我们需要的方法类型就OK了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Ref</span>() readonly hello!: &#123; <span class="attr">notify</span>: <span class="function">(<span class="params"><span class="keyword">from</span>?: string</span>) =&gt;</span> &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（10）Mixins"><a href="#（10）Mixins" class="headerlink" title="（10）Mixins"></a>（10）<code>Mixins</code></h3><p><code>vue-property-decorator</code>的<code>Mixins</code>方法完全来源于<code>vue-class-component</code>，使用方法如下。首先创建一个Mixin：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// visible-control-mixin.ts</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyMixin</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  visible = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">buttonText</span>(): string &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">visible</span> ? <span class="string">&#x27;Close&#x27;</span> : <span class="string">&#x27;Open&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">toggleVisible</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">visible</span> = !<span class="variable language_">this</span>.<span class="property">visible</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在组件中引入，这时候我们就不再需要组件继承自<code>Vue</code>了，而是继承自Mixin后的组件，<code>Mixins</code>方法可以接受个参数，作为混入的Mixin：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Mixins</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VisibleControlMixin</span> <span class="keyword">from</span> <span class="string">&#x27;@/mixins/visible-control-mixin&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MixinExample</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Mixins</span>(<span class="title class_">VisibleControlMixin</span>) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="（11）-Inject-x2F-Provide"><a href="#（11）-Inject-x2F-Provide" class="headerlink" title="（11）@Inject&#x2F;@Provide"></a>（11）<code>@Inject</code>&#x2F;<code>@Provide</code></h3><p><code>provide</code>和<code>inject</code>主要的目的就是透传属性，从一个根节点<code>provide</code>一个属性，无论多远的一个子节点都可以通过<code>inject</code>获得这个属性，与React的Context特性非常类似</p>
<p>虽然可以通过使用这两个属性，实现全局的数据共享，但是Vue的文档提示，这两个属性主要为高阶插件和组件库提供用例，并不直接推荐用于应用程序代码中，所以简单了解即可。</p>
<p>在根组件中使用<code>@Provide</code>提供数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span>, <span class="title class_">Provide</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Child</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/baseKnowledge/inject-provide/components/Child.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">InjectProvide</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Provide</span>() root = <span class="string">&#x27;Root&#x27;</span>;</span><br><span class="line">  @<span class="title class_">Provide</span>(<span class="string">&#x27;parent&#x27;</span>) readonly parentValue = <span class="string">&#x27;Grandpa&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 相当于</span></span><br><span class="line">  <span class="comment">//  provide() &#123;</span></span><br><span class="line">  <span class="comment">//   return &#123;</span></span><br><span class="line">  <span class="comment">//     root: &#x27;Root Initial Value&#x27;,</span></span><br><span class="line">  <span class="comment">//     parent: this.parentValue</span></span><br><span class="line">  <span class="comment">//   &#125;</span></span><br><span class="line">  <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在子组件中使用<code>@Inject</code>获取数据：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span>, <span class="title class_">Inject</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">InjectProvideChild</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">Inject</span>() readonly root!: string;</span><br><span class="line">  @<span class="title class_">Inject</span>() readonly parent!: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，<code>provide</code>和<code>inject</code>绑定并不是可响应的。这是刻意为之的。然而，如果传入了一个可监听的对象，那么其对象的属性还是可响应的。</p>
<p><code>vue-property-decorator</code>也提供了响应式插入数据的装饰器<code>@ProvideReactive</code>和<code>@InjectReactive</code>，但是有两个问题：</p>
<ol>
<li>无法与<code>@Inject</code>&#x2F;<code>@Provide</code>在同一个组件中同时工作</li>
<li>当从一个其他组件跳转到使用了<code>@ProvideReactive</code>和<code>@InjectReactive</code>后，会很有大概率报错<code>Error in nextTick: &quot;TypeError: Cannot redefine property: parent&quot;</code>导致渲染出错</li>
</ol>
<p>所以暂时不推荐使用这两个装饰器。</p>
<h1 id="3-改造Vue-Router"><a href="#3-改造Vue-Router" class="headerlink" title="3 改造Vue Router"></a>3 改造Vue Router</h1><p>使用Vue CLI创建的TypeScript项目，Vue Router与TypeScript配合基本不再需要进行额外的处理，除了对组件内的路由钩子方法需要提前进行注册。</p>
<p>使用<code>vue-class-component</code>提供的<code>Component.registerHooks</code>方法来提前注册，要注意，注册需要在引入路由之前完成</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./src/components/class-component-hooks.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在此注册其他插件提供的钩子函数，用来在 Vue Class 组件中使用</span></span><br><span class="line"><span class="comment">// 例如 Vue Router 提供的钩子函数</span></span><br><span class="line"><span class="comment">// 必须在 router 之前引入</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;vue-class-component&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Register the router hooks with their names</span></span><br><span class="line"><span class="title class_">Component</span>.<span class="title function_">registerHooks</span>([<span class="string">&#x27;beforeRouteEnter&#x27;</span>, <span class="string">&#x27;beforeRouteLeave&#x27;</span>, <span class="string">&#x27;beforeRouteUpdate&#x27;</span>]);</span><br></pre></td></tr></table></figure>

<p>在<code>main.ts</code>中引入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;@/components/class-component-hooks&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h1 id="4-改造Vuex"><a href="#4-改造Vuex" class="headerlink" title="4 改造Vuex"></a>4 改造Vuex</h1><p>Vuex与TypeScript配合会复杂一些，并且体验也不算太好，需要安全额外的包实现与TypeScript的配合使用，有三种方案来帮助我们使用TypeScript版本的Vuex</p>
<h2 id="4-1-使用vue-class-component"><a href="#4-1-使用vue-class-component" class="headerlink" title="4.1 使用vue-class-component"></a>4.1 使用<code>vue-class-component</code></h2><p>第一种方案是使用<code>vue-class-component</code>配合以前常常使用<code>mapState</code>等帮助方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Vuex&#x27;s component binding helper can use here</span></span><br><span class="line">    <span class="attr">computed</span>: <span class="title function_">mapState</span>([<span class="string">&#x27;count&#x27;</span>]),</span><br><span class="line">    <span class="attr">methods</span>: <span class="title function_">mapMutations</span>([<span class="string">&#x27;increment&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  <span class="comment">// additional declaration is needed</span></span><br><span class="line">  <span class="comment">// when you declare some properties in `Component` decorator</span></span><br><span class="line">  count!: number</span><br><span class="line">  increment!: <span class="function">() =&gt;</span> <span class="keyword">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种方式的好处是可以通过<code>mapState</code>等方法将Store中定义的数据、方法一次性引入组件，确定就是这种『一次性』其实也还需要在组件内部再次定义，并且如果采用这种形式配合<code>vue-property-decorator</code>使用时，会将计算属性、方法等逻辑打乱。另外，通过这种方式调用Mutation和Action，也不是类型安全的（即没有办法校验我们传入的参数是否与Store中定义的<code>payload</code>类型相匹配</p>
<h2 id="4-2-使用vuex-class"><a href="#4-2-使用vuex-class" class="headerlink" title="4.2 使用vuex-class"></a>4.2 使用<code>vuex-class</code></h2><p>第二种方案是<a target="_blank" rel="noopener" href="https://github.com/ktsn/vuex-class/"><code>vuex-class</code></a>，它与上一种方案相同，并没有对Vuex的Store中的代码进行改造，而是在组件消费Store中的数据、方法时，提供了一些遍历的API，简化使用方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Component</span>, <span class="title class_">Vue</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  <span class="title class_">State</span>,</span><br><span class="line">  <span class="title class_">Getter</span>,</span><br><span class="line">  <span class="title class_">Action</span>,</span><br><span class="line">  <span class="title class_">Mutation</span>,</span><br><span class="line">  namespace</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex-class&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someModule = <span class="title function_">namespace</span>(<span class="string">&#x27;path/to/module&#x27;</span>)</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">MyComp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">  @<span class="title class_">State</span>(<span class="string">&#x27;foo&#x27;</span>) stateFoo</span><br><span class="line">  @<span class="title class_">State</span>(<span class="function"><span class="params">state</span> =&gt;</span> state.<span class="property">bar</span>) stateBar</span><br><span class="line">  @<span class="title class_">Getter</span>(<span class="string">&#x27;foo&#x27;</span>) getterFoo</span><br><span class="line">  @<span class="title class_">Action</span>(<span class="string">&#x27;foo&#x27;</span>) actionFoo</span><br><span class="line">  @<span class="title class_">Mutation</span>(<span class="string">&#x27;foo&#x27;</span>) mutationFoo</span><br><span class="line">  @someModule.<span class="title class_">Getter</span>(<span class="string">&#x27;foo&#x27;</span>) moduleGetterFoo</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the argument is omitted, use the property name</span></span><br><span class="line">  <span class="comment">// for each state/getter/action/mutation type</span></span><br><span class="line">  @<span class="title class_">State</span> foo</span><br><span class="line">  @<span class="title class_">Getter</span> bar</span><br><span class="line">  @<span class="title class_">Action</span> baz</span><br><span class="line">  @<span class="title class_">Mutation</span> qux</span><br><span class="line"></span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateFoo</span> <span class="comment">// -&gt; store.state.foo</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">stateBar</span> <span class="comment">// -&gt; store.state.bar</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">getterFoo</span> <span class="comment">// -&gt; store.getters.foo</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">actionFoo</span>(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.dispatch(&#x27;foo&#x27;, &#123; value: true &#125;)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">mutationFoo</span>(&#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;) <span class="comment">// -&gt; store.commit(&#x27;foo&#x27;, &#123; value: true &#125;)</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">moduleGetterFoo</span> <span class="comment">// -&gt; store.getters[&#x27;path/to/module/foo&#x27;]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，给<code>namespace</code>传入的参数是Vuex中<code>module</code>的命名空间，并非模块的目录路径</p>
<p>这种方法虽然不能使用<code>mapState</code>等辅助函数，但是好在使用<code>@State</code>等装饰符集中导入，也还算清晰明了。但是缺点仍然是没有办法完全进行类型安全的Mutation和Action调用</p>
<h2 id="4-3-使用vuex-module-decorators"><a href="#4-3-使用vuex-module-decorators" class="headerlink" title="4.3 使用vuex-module-decorators"></a>4.3 使用<code>vuex-module-decorators</code></h2><p>如果想要实现获得完全类型安全的Vuex，那么就需要使用<a href="championswimmer/vuex-module-decorators"><code>vuex-module-decorators</code></a>，它对Vuex的Store也进行了Class化的改造，引入了<code>VuexModule</code>和<code>@Mutation</code>等修饰符，让我们能够使用Class形式来编写Store</p>
<p>使用的时候，按照下面的形式来改写Store：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Module</span>, <span class="title class_">Mutation</span>, <span class="title class_">Action</span>, <span class="title class_">VuexModule</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex-module-decorators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;@/store&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; setTimeoutThen &#125; <span class="keyword">from</span> <span class="string">&#x27;@/utils&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Module</span>(&#123; <span class="attr">dynamic</span>: <span class="literal">true</span>, <span class="attr">namespaced</span>: <span class="literal">true</span>, store, <span class="attr">name</span>: <span class="string">&#x27;testStore&#x27;</span> &#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">TestStore</span> <span class="keyword">extends</span> <span class="title class_ inherited__">VuexModule</span> &#123;</span><br><span class="line">  <span class="comment">// state</span></span><br><span class="line">  <span class="attr">message</span>: string = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">UpperMessage</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">message</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Mutation</span></span><br><span class="line">  <span class="title function_">UPDATE_MESSAGE_MUTATION</span>(<span class="attr">title</span>: string): <span class="keyword">void</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">message</span> = title;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Action</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">UPDATE_MESSAGE_ACTION</span>(): <span class="title class_">Promise</span>&lt;string&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">result</span>: string = <span class="keyword">await</span> setTimeoutThen(<span class="number">1000</span>, <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">context</span>.<span class="title function_">commit</span>(<span class="string">&#x27;UPDATE_MESSAGE_MUTATION&#x27;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要注意，改写的Module在<code>@Module</code>中传入了几个属性，传入<code>namesapced</code>和<code>name</code>来使用Module成为命名空间下的模块，此外还需要传入<code>dynamic</code>，让这个模块成为<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/modules.html#%E6%A8%A1%E5%9D%97%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C">动态注册</a>的模块，同时还需要将完全空白的<code>store</code>传入给这个模块</p>
<p>完成改造之后，在使用的时候就可以使用他提供的<code>getModule</code>方法获得类型安全了，使用方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getModule &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex-module-decorators&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestStore</span> <span class="keyword">from</span> <span class="string">&#x27;@/store/modules/testStore&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testStore = <span class="title function_">getModule</span>(<span class="title class_">TestStore</span>);</span><br><span class="line">testStore.<span class="property">message</span>;</span><br><span class="line">testStore.<span class="title function_">UPDATE_MESSAGE_MUTATION</span>(<span class="string">&#x27;Hello&#x27;</span>);</span><br><span class="line">testStore.<span class="title function_">UPDATE_MESSAGE_ACTION</span>();</span><br></pre></td></tr></table></figure>

<p>当我们调用Mutation的时候，它会自动校验我们传入的参数的类型，与我们定义在Store中的<code>payload</code>类型是否匹配，如果不匹配TS就会给出错误提示</p>
<p>这种方案的好处就是能够获得类型安全，缺点就是对Store的也有比较大的改动，而且只能定义动态注册的命名空间下的模块，这也就意味着，如果想在根节点下注册全局状态时无法实现的（毕竟这个包的名字就是<code>vuex-module-decorators</code>）</p>
<h2 id="4-4-最终选择vuex-class"><a href="#4-4-最终选择vuex-class" class="headerlink" title="4.4 最终选择vuex-class"></a>4.4 最终选择<code>vuex-class</code></h2><p>我选择了使用第二种方案，相比于第一种方案能够将组件内的逻辑几种，并且通过相关的修饰符能够显示的提醒代码的含义。相比于第三种方案编写复杂度也有了一定降低</p>
<p>对于类型安全我的做法是，当在组件内引入Mutation时再次编写对应的函数接口，在Vuex中编写的时候，通过引入Vuex提供的类型配合自定义类型，保证类型安全。</p>
<p>具体的实践在我们『相关实践』部分会有更具体写的介绍。</p>
<h1 id="5-相关实践"><a href="#5-相关实践" class="headerlink" title="5 相关实践"></a>5 相关实践</h1><h2 id="5-1-TypeScript类型校验"><a href="#5-1-TypeScript类型校验" class="headerlink" title="5.1 TypeScript类型校验"></a>5.1 TypeScript类型校验</h2><p>Vue-CLI使用的TypeScript插件是<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli-plugin-typescript/README.md/"><code>@vue/cli-plugin-typescript</code></a>，它将<code>ts-loader</code>和<a target="_blank" rel="noopener" href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin"><code>fork-ts-checker-webpack-plugin</code></a>配合使用，实现线程外的快速类型检查。</p>
<p>在默认配置下，如果发现了TypeScript类型错误，仅仅会在终端进行提示，而不会中断编译过程。我认为TypeScript发现的类型错误是比较严重的错误类型，应当中断编译过程，让开发者给予足够的重试，所以需要进行配置，让TypeScript发现的错误中断编译过程并且在浏览器界面上进行提示。</p>
<p>常规的TypeScript项目只需要在<code>tsconfig.json</code>中的<code>compilerOptions</code>选项中配置<code>noEmitOnError</code>即可，这就会阻止TypeScript编译器在发现错误的时候继续将<code>.ts</code>文件编译成为<code>.js</code>文件。</p>
<p>但是由于Vue CLI使用了<code>fork-ts-checker-webpack-plugin</code>这个插件，需要进行额外的配置（在<code>@vue/cli-plugin-typescript</code>的文档中并没有明确的介绍，需要到<code>fork-ts-checker-webpack-plugin</code>的文档中自行查找）</p>
<p>在<code>vue.config.js</code>中，使用<code>chainWebpack</code>属性，对其进行配置，将<code>async</code>设置为<code>false</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 配置 TypeScript 检查配置</span></span><br><span class="line">    <span class="comment">// https://github.com/TypeStrong/fork-ts-checker-webpack-plugin#options</span></span><br><span class="line">    config.<span class="title function_">plugin</span>(<span class="string">&#x27;fork-ts-checker&#x27;</span>).<span class="title function_">tap</span>(<span class="function"><span class="params">option</span> =&gt;</span> &#123;</span><br><span class="line">      option[<span class="number">0</span>].<span class="property">async</span> = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> option;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>另外，在<code>tsconfig.json</code>中的<code>compilerOptions</code>选项中将<code>noImplicitAny</code>设定为<code>true</code>，这样如果编译器推导出的结果默认为<code>any</code>的话，编译器会报错。不推荐轻易使用<code>any</code>，除非有明确的理由。即使需要<code>any</code>也要现实的标注为<code>any</code>，这样才能享受到TypeScript的强类型提示的好处（更何况这不是一个就项目改造）</p>
<h2 id="5-2-Lint工具"><a href="#5-2-Lint工具" class="headerlink" title="5.2 Lint工具"></a>5.2 Lint工具</h2><p>配置比较高的Lint级别，可能会导致开发时的效率稍微降低，但是有助于项目的长期发展，以及良好的代码习惯的养成，也避免了保存代码时不提示，但是在Commit时一堆错误不好修改的问题。</p>
<p>配置的Lint工具包括了：</p>
<h3 id="（1）ESLint"><a href="#（1）ESLint" class="headerlink" title="（1）ESLint"></a>（1）ESLint</h3><p>使用了<code>plugin:vue/recommended</code>&#x2F;<code>@vue/prettier</code>&#x2F;<code>@vue/typescript</code>&#x2F;<code>plugin:prettier/recommended</code>四个规则，使用<code>@typescript-eslint/parser</code>解析器对<code>.vue</code>文件和<code>.ts</code>文件都会进行校验（这些都是Vue CLI自动配置的）。</p>
<p>同时在<code>vue.config.js</code>中配置了<code> lintOnSave: process.env.NODE_ENV === &#39;development&#39; ? &#39;error&#39; : &#39;false&#39;,</code> 让ESLint检测到错误时不仅在终端中提示，还会在浏览器界面上展示，同时中断编译过程</p>
<h3 id="（2）Prettier"><a href="#（2）Prettier" class="headerlink" title="（2）Prettier"></a>（2）Prettier</h3><p>配置了Prettier，根据它提供的不多的选项进行了配置，有可能会与公司代码提交平台的规范有冲突，如果发现冲突后面再进行调整。</p>
<p>由于ESLint中配置了<code>@vue/prettier</code>和<code>plugin:prettier/recommended</code>，Prettier发现的错误也会中断编译过程。</p>
<p>不过Prettier的问题相对比较好修复，IDE中配置好Prettier的插件后，可以一键进行修复。</p>
<h3 id="（3）StyleLint"><a href="#（3）StyleLint" class="headerlink" title="（3）StyleLint"></a>（3）StyleLint</h3><p>对于样式文件使用StyleLint进行了检查，在<code>vue.config.js</code>中通过<code>configureWebpack</code>方法引入了StyleLint插件，对所有样式文件以及<code>.vue</code>单文件组件、HTML组件中的样式代码进行校验。</p>
<p>同样如果出错会中断编译过程（这个应该是Bug，即便想关闭配置了相关选项后也无法关闭）</p>
<p>在<code>.stylelintrc.js</code>中定义了一些规则，也可能与公司的代码规范有冲突，后续进行调整。</p>
<h2 id="5-3-目录组织"><a href="#5-3-目录组织" class="headerlink" title="5.3 目录组织"></a>5.3 目录组织</h2><p>这部分也是我个人的尝试，带有一定个人喜好，希望在这个项目中验证是否可行。</p>
<h3 id="（1）types-ts文件"><a href="#（1）types-ts文件" class="headerlink" title="（1）types.ts文件"></a>（1）<code>types.ts</code>文件</h3><p>一般来说，如果<code>.vue</code>文件或者其他的<code>.ts</code>文件，如果涉及到的类型不多不复杂，可以直接在文件中进行定义，但是如果对应的类型接口需要复用，或者比较多，最好将原来的文件变为目录，文件名改为<code>index</code>，里面配套添加<code>types.ts</code>文件，用来声明类型，例如有一个<code>example.ts</code>文件，如果需要定义的类型比较复杂，那么将这个文件替换为：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- example</span><br><span class="line">  |</span><br><span class="line">  - index.ts</span><br><span class="line">  - types.ts</span><br></pre></td></tr></table></figure>

<h3 id="（2）目录组织"><a href="#（2）目录组织" class="headerlink" title="（2）目录组织"></a>（2）目录组织</h3><p>基本按照Vue CLI生成目录结构，各个插件的配置文件（例如<code>.eslintrc.js</code>、<code>.eslintignore</code>文件）、环境配置文件（例如<code>.env</code>）都放置在根目录，ElementUI定制样式文件放置在根目录下的<code>theme</code>目录，其余文件都放在<code>src</code>目录下。（<code>test</code>目录是单元测试文件的目录，暂时没有引入单测的计划，不过在业务空闲期可能会考虑使用Jest进行单元测试）</p>
<p>Vue CLI为我们配置了Webpack的Alias，<code>@</code>会指向<code>src</code>目录，所以导入文件时，除非是只被一个组件引用的内部组件可使用<code>./</code>相对路径，其余路径都建议使用<code>@</code>进行引入，保证文件移动时无需关注组件和资源的路径问题。</p>
<p><code>src</code>目录下，除了根目录下的几个文件<code>App.vue</code>等之外，还有以下几个目录：</p>
<p>（1）<code>src/assets</code>目录，将所有前端的资源（图片、音频、视频、字体等）都建立单独的目录放到该目录下，例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  |</span><br><span class="line">  - assets</span><br><span class="line">    |</span><br><span class="line">    - images</span><br><span class="line">    - videos</span><br><span class="line">    - icons</span><br></pre></td></tr></table></figure>

<p>如果图片资源比较多，还可以在<code>images</code>目录下按模块进行分割</p>
<p>（2）<code>src/components</code>目录，这里放置的组件应该是一些自己封装的、作为模块的功能化基础组件，例如在ElementUI基础上根据封装的组件，会被多个页面引用，例如自己封装的筛选组件等。</p>
<p>这里的结构应该只有单层，即一个目录是一个<code>component</code>，不再划分新的目录（组件内部可以根据需要划分子目录）：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  |</span><br><span class="line">  - components</span><br><span class="line">    |</span><br><span class="line">    - query</span><br><span class="line">      |</span><br><span class="line">      - index.vue</span><br><span class="line">        |</span><br><span class="line">        - components</span><br><span class="line">          |</span><br><span class="line">          - handler.vue</span><br><span class="line">          - result.vue</span><br><span class="line">    - user-list</span><br><span class="line">      |</span><br><span class="line">      - index.vue</span><br></pre></td></tr></table></figure>

<p>（3）<code>src/mixins</code>，放置Mixin文件，不再划分目录，通过文件名和注释描述该文件实现的Mixin的功能</p>
<p>（4）<code>src/plugins</code>，引入的或者自己实现的插件，目录要求与<code>components</code>相同</p>
<p>（5）<code>src/router</code>，路由相关文件，具体在路由部分的实践介绍</p>
<p>（6）<code>src/store</code>，Vuex相关文件，具体在Vuex部分的实践介绍</p>
<p>（7）<code>src/styles</code>，样式相关文件，只放置全局的样式变量和样式Mixin，通过Style-resource-loader配置自动进行引入</p>
<p>（8）<code>src/utils</code>，帮助函数的目录，总的出口文件是<code>index.ts</code>，用于组织帮助函数的分类，其余文件按照帮助函数的类别进行划分，无法分类比较零散的帮助函数放置在<code>common-helper</code>，目前其他的帮助函数分为了下面几个：</p>
<ul>
<li><code>date-time-helper.ts</code>，用来处理日期时间相关的函数都在这里</li>
<li><code>router-helper.ts</code>，与路由相关的函数在这里，例如路由守卫中应用的方法等</li>
<li><code>network-helper</code>，与网络请求有关的方法都在这里，最主要的就是对Axios的封装，在后面的网络请求部分单独介绍</li>
</ul>
<p>（9）<code>src/views</code>，是最常用的目录，里面按照模块划分目录（可以大致理解为按照导航菜单的一级目录划分），里面有一个<code>common</code>目录，用来放置被多个页面同时引用的组件。</p>
<p>例如有一个<code>user-create.vue</code>，在<code>user-info</code>路由下有使用，在<code>user-admin</code>中也有使用，那么就可以把它放到<code>common</code>中：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  |</span><br><span class="line">  - views</span><br><span class="line">    |</span><br><span class="line">    - common</span><br><span class="line">      |</span><br><span class="line">      - user</span><br><span class="line">        |</span><br><span class="line">        - user-create.vue</span><br></pre></td></tr></table></figure>

<p>现在的<code>common</code>目录下有两个组件，分别是<code>not-found</code>（对应404路由）和<code>menu</code>目录，不过这个目录的划分可能会比较主观，也会随着业务不同进行调整。</p>
<h2 id="5-4-命名"><a href="#5-4-命名" class="headerlink" title="5.4 命名"></a>5.4 命名</h2><p>这里的命名风格主要参考了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/style-guide/index.html">Vue的风格指南</a>和Element的实践</p>
<h3 id="（1）目录的命名"><a href="#（1）目录的命名" class="headerlink" title="（1）目录的命名"></a>（1）目录的命名</h3><p>目录使用<code>kebab-case</code>格式进行命名，如果里面的主文件使用<code>index.ts</code>或者<code>index.vue</code>命名，如果有子组件则放到与<code>index</code>平级的<code>components</code>目录下，例如：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  |</span><br><span class="line">  - views</span><br><span class="line">    |</span><br><span class="line">    - layout.vue</span><br><span class="line">      |</span><br><span class="line">      - index.vue</span><br><span class="line">      - components</span><br><span class="line">        |</span><br><span class="line">        - header.vue</span><br><span class="line">        - main.vue</span><br><span class="line">        - footer.vue</span><br></pre></td></tr></table></figure>

<p>另外，<strong>如果一个组件的代码长度超过了300行，就需要考虑拆分组件了，如果超过了500行，则必须拆分组件</strong>。</p>
<p>这样做的好处是，当进入一个目录后，一眼就能看出主文件是哪一个，对应的组件在哪里。缺点就是当在IDE中打开多个文件时，每个代码文件的文件名为防止重名会变得很长，不太便于切换。</p>
<h3 id="（2）组件的命名"><a href="#（2）组件的命名" class="headerlink" title="（2）组件的命名"></a>（2）组件的命名</h3><p>如果组件不以目录的形式存在，而是一个单独的组件，则使用<code>kebab-case</code>格式进行命名，例如<code>user-store.ts</code>、<code>user-list.vue</code>。</p>
<p>在编写组件时，导出的Class的名字需要是<code>PascalCase</code>格式的，且语义正确：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">Component</span>()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入组件时，也按照<code>PascalCase</code>格式进行导入和注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">UserList</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/user-list/index.vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Component</span>(&#123; <span class="attr">components</span>: &#123; <span class="title class_">UserList</span> &#125; )</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在模板中使用的时候，需要使用<code>kebab-case</code>格式，例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">user-lit</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在单文件组件、字符串模板和JSX中没有内容的组件应该是自闭合的（在DOM模板中不可以）</p>
</blockquote>
<p>这样做的好处是符合HTML和JS的语言规范，但是就是当我在组件里想要找到<code>UserList</code>时会习惯的直接搜索<code>Userlist</code>却搜不到。</p>
<h3 id="（3）变量的命名"><a href="#（3）变量的命名" class="headerlink" title="（3）变量的命名"></a>（3）变量的命名</h3><p>变量的命名由ESLint控制，要求使用驼峰拼写法，这也和公司准入平台的要求是一致的。</p>
<p>组件的Prop的命名应该遵循的规则：在声明Prop的时候，命名始终使用<code>camelCase</code>，在模板中使用<code>kebab-case</code>：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">User</span> <span class="attr">user-name</span>=<span class="string">&quot;Jay&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">import</span> <span class="title class_">User</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/user/index.vue&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">@<span class="title class_">Component</span>(&#123; <span class="attr">components</span>: &#123; <span class="title class_">User</span> &#125; )</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">UserList</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vue</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  @<span class="title class_">Prop</span>(<span class="title class_">String</span>) username!: string;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="（4）接口的命名"><a href="#（4）接口的命名" class="headerlink" title="（4）接口的命名"></a>（4）接口的命名</h3><p>此处指的接口是TypeScript中的<code>interface</code>，命名应遵循<code>PascalCase</code>规则：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface <span class="title class_">RootState</span> &#123;</span><br><span class="line">  <span class="attr">title</span>: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-类型"><a href="#5-5-类型" class="headerlink" title="5.5 类型"></a>5.5 类型</h2><p>为了充分享受TypeScript带来的强类型的好处，提高项目的可维护性和代码质量，我在项目中开启了<code>noImplicitAny</code>，即所有的隐式的<code>any</code>类型都不不被允许的。</p>
<p>所以对于比较复杂的类型、变量建议显示的定义类型，简单的可以令编译器自动推导来确定。</p>
<p>谨慎使用<code>any</code>类型，对于<code>as</code>断言的使用也要仔细考虑是否合理。</p>
<h2 id="5-6-路由"><a href="#5-6-路由" class="headerlink" title="5.6 路由"></a>5.6 路由</h2><p>路由的目录是<code>./src/router</code>，<code>index.ts</code>是实际进行路由组装的地方，在<code>modules</code>中按照目录对路由进行了分割代理，分割的维度也可以认为是按照导航的一级目录。在<code>router-guards.ts</code>中定义路由守卫相关的功能。</p>
<h3 id="（1）按模块组织路由"><a href="#（1）按模块组织路由" class="headerlink" title="（1）按模块组织路由"></a>（1）按模块组织路由</h3><p>在<code>modules</code>中，每个模块是一个<code>.ts</code>文件，具体的业务模块都在这里定义，例如我定义了一个<code>base-knowledge.ts</code>模块，里面的路由都是与『基础知识』相关的路由定义，路由对象的类型直接使用了<code>vue-router</code>定义的<code>RouteConfig</code></p>
<blockquote>
<p>要善于利用第三方包已经定义好的类型，具体可以在IDE中按住<code>alt</code>点击进入其类型声明文件，选择使用。</p>
</blockquote>
<p>Route对象的定义与Vue Route需要的路由对象一直，在<code>meta</code>中定义我们需要自定义的数据，具体的路由守卫都在<code>router-guards.ts</code>中定义，在此引用。</p>
<p>引入组件的时候，使用了<code>lazyLoaderHelper</code>辅助函数，在生产环境中会实现路由懒加载，所以引入组件的方式与原来不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">baseKnowledgeRoutes</span>: <span class="title class_">RouteConfig</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/base/hello-vue&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;base&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title function_">lazyLoadHelper</span>(<span class="string">&#x27;base-knowledge/hello-vue/index&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> baseKnowledgeRoutes;</span><br></pre></td></tr></table></figure>

<p>传给<code>lazyLoadHelper</code>参数是组件位于<code>./src/views/</code>路径下的目录和文件名，不必添加<code>.vue</code>后缀（其实看一下<code>lazyLoadHelper</code>的实现就明白了），上面导入的组件实际路径是<code>./src/view/base-knowledge/hello-vue/index.vue</code></p>
<p>这样带来的弊端就是IDE搜索组件引用的时候没有办法直接按照建立的索引搜索到组件的使用，因为我们传入的是字符串形式的路径，所以在搜索组件引用时候需要到这个目录下使用字符串搜索的形式进行搜索</p>
<blockquote>
<p>如果业务复杂，或者需要再嵌套子路由，后续可以在<code>modules</code>中再换按照目录进行划分，组织形式类似</p>
</blockquote>
<h3 id="（2）路由汇总"><a href="#（2）路由汇总" class="headerlink" title="（2）路由汇总"></a>（2）路由汇总</h3><p>在<code>./src/router/index.ts</code>中对各个模块进行汇总，汇总的方式就是采取结构赋值的形式，同时将一些公用的、有特定顺序的路由（例如<code>404</code>）插入到最终的<code>routes</code>对象中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteConfig</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title function_">lazyLoadHelper</span>(<span class="string">&#x27;home/index&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Vue Learning Demos&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...baseKnowledge,</span><br><span class="line">  ...application,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="title function_">lazyLoadHelper</span>(<span class="string">&#x27;common/not-found&#x27;</span>),</span><br><span class="line">    <span class="attr">meta</span>: &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Not Found&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123; routes &#125;);</span><br></pre></td></tr></table></figure>

<p>同时路由守卫也是在这里进行组装的。</p>
<h3 id="（3）导航"><a href="#（3）导航" class="headerlink" title="（3）导航"></a>（3）导航</h3><p>设置完路由后，大部分情况下需要在导航菜单中进行处理。项目中关于菜单的组件我放在了<code>./src/views/common/menu</code>目录下</p>
<p>导航组件是基于<code>&lt;el-menu&gt;</code>封装的视图组件，基本上不会被其他组件引用，也没有做太多通用性的抽象，所在放到了<code>views/common</code>中而没有放到<code>components</code>中。</p>
<p><code>menu</code>目录下有三个文件：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- src</span><br><span class="line">  |</span><br><span class="line">  - views</span><br><span class="line">    |</span><br><span class="line">    - common</span><br><span class="line">      |</span><br><span class="line">      - menu</span><br><span class="line">        |</span><br><span class="line">        - index.vue</span><br><span class="line">        - config.ts</span><br><span class="line">        - types.ts</span><br></pre></td></tr></table></figure>

<p><code>index.vue</code>是导航的主文件，用来将数据映射为视图，<code>types.ts</code>是前面提到的类型文件，而剩下的<code>config.ts</code>就是视图的数据来源。格式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">menuConfigs</span>: <span class="title class_">MenuConfig</span>[] = [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/base&#x27;</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;el-icon-location&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;基础知识&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/base/hello-vue&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Hello Vue&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-location&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/base/life-circles&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Life Circles&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-location&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/base/inject-and-provide&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Inject/Provide&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-location&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">path</span>: <span class="string">&#x27;/base/mixin-example&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Mixin Example&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-location&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/application&#x27;</span>,</span><br><span class="line">    <span class="attr">icon</span>: <span class="string">&#x27;el-icon-basketball&#x27;</span>,</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&#x27;综合应用&#x27;</span>,</span><br><span class="line">    <span class="attr">children</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/application/todo-list&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;Todo List&#x27;</span>, <span class="attr">icon</span>: <span class="string">&#x27;el-icon-basketball&#x27;</span> &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p><code>menuConfigs</code>数组的成员都是一级菜单的属性，成员的<code>children</code>属性是二级菜单的属性。可以添加哪些属性看<code>types.ts</code>中的定义即可。如果添加了错误的或者不存在的属性，TypeScript编译器就会报错，不必等到编译成功后在浏览器中看不到预期的结果才发现属性传错，这就是TypeScript静态检查带来的好处之一。</p>
<blockquote>
<p>我们的导航组件目录只支持二级导航</p>
</blockquote>
<h2 id="5-7-Vuex"><a href="#5-7-Vuex" class="headerlink" title="5.7 Vuex"></a>5.7 Vuex</h2><p>关于Vuex的代码都在<code>.src/store</code>目录中，目录分为了三个部分，<code>index.ts</code>组装Store，不负责具体的实现，<code>root-sotre</code>来定义根Store的具体实现，<code>modules</code>中按目录实现各个模块的Store</p>
<h3 id="（1）Store目录划分"><a href="#（1）Store目录划分" class="headerlink" title="（1）Store目录划分"></a>（1）Store目录划分</h3><p>在<code>root-store</code>中定义根Store的具体实现，在<code>modules</code>里面按目录定义各模块的Store的实现，每个模块目录建议以<code>模块名-store</code>命名，导出时根节点的Store将各个属性分别导出，插入到<code>index.ts</code>中<code>new Vuex.Store</code>的各个属性中，子模块的Stroe直接将模块整体插入到<code>new Vuex.Store</code>的<code>modules</code>属性中，属性名（即命名空间）以模块名命名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">RootStore</span> <span class="keyword">from</span> <span class="string">&#x27;@/store/root-store/index&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TodoStore</span> <span class="keyword">from</span> <span class="string">&#x27;@/store/modules/todo-store/index&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">  <span class="attr">strict</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">  <span class="attr">state</span>: <span class="title class_">RootStore</span>.<span class="property">state</span>,</span><br><span class="line">  <span class="attr">getters</span>: <span class="title class_">RootStore</span>.<span class="property">getters</span>,</span><br><span class="line">  <span class="attr">mutations</span>: <span class="title class_">RootStore</span>.<span class="property">mutations</span>,</span><br><span class="line">  <span class="attr">actions</span>: <span class="title class_">RootStore</span>.<span class="property">actions</span>,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">    <span class="attr">todo</span>: <span class="title class_">TodoStore</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="（2）Store的实现"><a href="#（2）Store的实现" class="headerlink" title="（2）Store的实现"></a>（2）Store的实现</h3><p>根Store（以及其他每个Module的Store）都应该包含三个文件：</p>
<p>（1）<code>index.ts</code>，用来定义Store的具体实现，例如<code>state</code>、<code>getters</code>、<code>Mutation</code>和<code>Action</code>等，</p>
<p>（2）<code>interface-types.ts</code>是用来定义Store对应的类型的文件（因为还存在另外一个<code>store-types.ts</code>文件，所以命名为<code>interface-types.ts</code>），这里面也大量借用了<code>vuex</code>提供了类型帮助构建我们自己的类型，具体实现可以参考代码。</p>
<p>（3）<code>store-types.ts</code>用来定义Mutation的Type常量，实际上由于Mutation、Action的Type在Store中、组件中以及上面定义类型的<code>interface-types.ts</code>中，所以需要在这里定义常量然后导出</p>
<p>另外，由于在之前的项目中，API是单独划分目录存放的，但是实际上目录结构与Store中的结构相同，并且在新项目中我仍然准备所有API请求都都通过Action完成，相当于API与Store也是强耦合的，所以我定义Mutaion和Action的Type常量时，我将对应的URL也作为一个常量保存在了<code>store-types.ts</code>中。例如我们有要完成的Action是更新标题，那么在<code>store-types.ts</code>中我会做如下的定义：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE_URL</span> = <span class="string">&#x27;/title&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE_MUTATION</span> = <span class="string">&#x27;UPDATE_TITLE_MUTATION&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE_ACTION</span> = <span class="string">&#x27;UPDATE_TITLE_ACTION&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我将上面三个常量成为为一组Type，注意，常量命名应该全大写，以<code>_</code>分割，结尾单词是固定的，以<code>MUTATION</code>&#x2F;<code>ACTION</code>&#x2F;<code>URL</code>结尾，用来表明类型。多组常量之间应该间隔一个空行。</p>
<p>这一组Type有可能会包含一个URL，但是对应多个Mutaion和Action，例如严格遵守REST风格的API接口是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">TITLE_URL</span> = <span class="string">&#x27;/title&#x27;</span>;</span><br><span class="line"><span class="comment">// 对应 PUT 方法，更新资源</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE_MUTATION</span> = <span class="string">&#x27;UPDATE_TITLE_MUTATION&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE_ACTION</span> = <span class="string">&#x27;UPDATE_TITLE_ACTION&#x27;</span>;</span><br><span class="line"><span class="comment">// 对应 POST 方法，创建资源</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CREATE_TITLE_MUTATION</span> = <span class="string">&#x27;UPDATE_TITLE_MUTATION&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CREATE_TITLE_ACTION</span> = <span class="string">&#x27;UPDATE_TITLE_ACTION&#x27;</span>;</span><br><span class="line"><span class="comment">// 对应 GET 方法，获取资源</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">GET_TITLE_MUTATION</span> = <span class="string">&#x27;UPDATE_TITLE_MUTATION&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">GET_TITLE_ACTION</span> = <span class="string">&#x27;UPDATE_TITLE_ACTION&#x27;</span>;</span><br></pre></td></tr></table></figure>


<blockquote>
<p>想到过采用一个对象里面多个属性的方式来维护，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">UPDATE_TITLE</span> = &#123;</span><br><span class="line">  <span class="attr">mutation</span>: <span class="string">&#x27;UPDATE_TITLE_MUTATION&#x27;</span>,</span><br><span class="line">  <span class="attr">action</span>: <span class="string">&#x27;UPDATE_TITLE_ACTION&#x27;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;title&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是在<code>interface-types.ts</code>中用这个变量来定义对应的Mutaion或者Action的类型时会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> interface <span class="title class_">RootMutations</span> <span class="keyword">extends</span> <span class="title class_">MutationTree</span>&lt;<span class="title class_">RootState</span>&gt; &#123;</span><br><span class="line">  [<span class="variable constant_">UPDATE_TITLE</span>.<span class="property">action</span>]: <span class="title class_">RootUpdateTitleMutation</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Error:(16, 3) TS1169: A computed property name in an interface must refer</span></span><br><span class="line"><span class="comment">// to an expression whose type is a literal type or a &#x27;unique symbol&#x27; type.</span></span><br></pre></td></tr></table></figure>

<p>就是说如果对象的属性名是一个用<code>[]</code>包裹的计算属性，那么计算属性只能是字面量或者是<code>unique symbol</code>类型，字面量就是我现在才去的方案，而如果要使用<code>unique symbol</code>又遇到了<a target="_blank" rel="noopener" href="https://github.com/vuejs/vuex/issues/224/">Vuex不支持<code>Symbol</code>类型作为Mutation Type的限制</a>，所以只能采取了上面的方案。</p>
</blockquote>
<p>使用常量的时候直接将常量导入，属性名使用<code>[]</code>的形式来插入常量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">UPDATE_TITLE_MUTATION</span>, <span class="variable constant_">UPDATE_TITLE_ACTION</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@/store/root-store/store-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">mutations</span>: <span class="title class_">RootMutations</span> = &#123;</span><br><span class="line">  [<span class="variable constant_">UPDATE_TITLE_MUTATION</span>](state, &#123; title &#125;) &#123;</span><br><span class="line">    state.<span class="property">title</span> = title;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">actions</span>: <span class="title class_">RootActions</span> = &#123;</span><br><span class="line">  <span class="keyword">async</span> [<span class="variable constant_">UPDATE_TITLE_ACTION</span>](&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="attr">result</span>: string = <span class="keyword">await</span> setTimeoutThen(<span class="number">1000</span>, <span class="string">&#x27;ok&#x27;</span>);</span><br><span class="line">    <span class="title function_">commit</span>(<span class="variable constant_">UPDATE_TITLE_MUTATION</span>, &#123; <span class="attr">title</span>: result &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; state, getters, mutations, actions &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="（3）什么数据需要存到Store中"><a href="#（3）什么数据需要存到Store中" class="headerlink" title="（3）什么数据需要存到Store中"></a>（3）什么数据需要存到Store中</h3><p>需要共享的全局数据自不必说，需要存到Store中，而且一般要放到<code>root-store</code>中</p>
<p>对于组件中的数据，如果组件内有多个子组件共享数据建议也放到Store中的<code>state</code>中进行维护，如果父组件获取数据不全仍需要子组件通过网络请求获取数据的情况，不建议放到Store中。</p>
<p>例如，有一个组件<code>UserList</code>，保存了用户数据列表，<code>User</code>是子组件，点击<code>UserList</code>其中一列会打开<code>User</code>组件，展示用户详情，如果：</p>
<ul>
<li><code>User</code>展示的详情数据在<code>UserList</code>中已经完全具备，<code>User</code>不需要再通过网络请求获取数据，那么<code>UserList</code>的数据建议放到Store中，在Action中将数据<code>commit</code>到<code>state</code>中</li>
<li>如果情况相反，则不建议将<code>UserList</code>的数据建议放到Store中，不需要<code>commit</code>，直接<code>return</code>返回的数据</li>
</ul>
<h3 id="（4）缓存"><a href="#（4）缓存" class="headerlink" title="（4）缓存"></a>（4）缓存</h3><p>对于<code>root-store</code>中的数据应该有全局缓存的功能，如果请求的数据短期内不变，就不必再次发送网络请求，简单做的话就是对<code>root-store</code>中的每个请求进行判断，如果State中数据已经存在则直接返回该数据</p>
<p>这样做需要每个请求单独处理，而且实现的功能比较简陋，比较完善的全局缓存我能想到的是：</p>
<ol>
<li>不需要每个请求（即<code>dispatch</code>每个Action）时都需要处理，那么也许将缓存这一部分与Axios的封装结合在一起比较好</li>
<li>为缓存添加可控制的属性，比如最大缓存时间、强制忽略缓存等</li>
<li>缓存控制的粒度，是以请求为粒度，还是URL作为更细的控制粒度？</li>
<li>当多个请求请求同一份资源的时候，后续请求如何处理？是直接忽略缓存发送多个请求（简单粗暴）？还是使用资源池配合监听订阅模式实现效率最大化（精致复杂）？</li>
</ol>
<p>这一块我还没有进行处理，后面有了具体的实践经验再来补充。</p>
<h2 id="5-8-网络请求处理"><a href="#5-8-网络请求处理" class="headerlink" title="5.8 网络请求处理"></a>5.8 网络请求处理</h2><h3 id="（1）Axios的封装"><a href="#（1）Axios的封装" class="headerlink" title="（1）Axios的封装"></a>（1）Axios的封装</h3><p>项目的网络工具选了最主流的Axios，在<code>utiles/network-helper</code>中进行了处理，这个目录下除了<code>types.ts</code>是类型声明文件，<code>index.ts</code>是具体实现的主文件，<code>loading-counter.ts</code>是用来对全局Loading进行处理的方法。</p>
<p>对Axios的封装其实还是老一套，只是没有直接导出的<code>get</code>等方法，而是作为<code>request</code>的一个属性，按照<code>request.get</code>的形式使用。</p>
<p>在<code>index.ts</code>也添加了一些Interceptors，目前主要添加的功能时错误提示、Loading处理，后面会加上对请求参数自动拼装（例如JWT参数）。后续如果Interceptors比较多，可以单独拆分文件维护。</p>
<p>要注意的是，对错误的拦截，如果是网络异常导致的错误，拦截器会进行提示后，将错误对象<code>reject</code>，在<code>main.ts</code>的<code>Vue.config.errorHandler</code>统一处理，如果是业务返回的错误码，会在拦截器中进行提示，错误对象会<code>resolve</code>，响应结果在业务代码中处理（单不需要处理Loading和提示错误了）</p>
<h3 id="（2）全局Loading"><a href="#（2）全局Loading" class="headerlink" title="（2）全局Loading"></a>（2）全局Loading</h3><p><code>loading-counter.ts</code>中定义了<code>LoadingCounter</code>这个类，并导出了一个实例，在Axios的成功的请求拦截器中Loading数<code>+1</code>，失败的请求拦截器不作处理，在成功或失败的响应拦截器中Loading数<code>-1</code>，并提供了<code>clearLoading</code>方法强制清除Loading，</p>
<p>这个方案的优点就是不需要再网络请求时反复的添加Loading的处理逻辑，缺点就是只能默认添加全屏的Loading，而且实现比较简单，没有经过复杂项目的验证，可能由于欠考虑导致什么潜在的问题。</p>
<h3 id="（3）Mock数据"><a href="#（3）Mock数据" class="headerlink" title="（3）Mock数据"></a>（3）Mock数据</h3><p>前端Mock数据选择了使用<a target="_blank" rel="noopener" href="https://hellosean1025.github.io/yapi/index.html">Yapi</a>来完成（<a target="_blank" rel="noopener" href="http://yapi.baidu-int.com/group/10871">内网地址</a>），让前端编写Mock数据能够更加轻松，它采用了<a target="_blank" rel="noopener" href="http://mockjs.com/">Mock.js</a>的语法，也可以自己编写Mock脚本来实现复杂数据的输出。</p>
<p>其实它完全可以充当API的文档，不过需要后端的配合，一般实现起来是比较难的，所以可以前端自己来维护一份Mock的API。</p>
<p>理想状态时，在本地开发时，所有请求都应该是通过Mock完成的，这样有一些数据在测试环境也没有办法获取到真实反映（例如车辆接管数据，需要同步到Monitor，所以后端只返回一种结果），但是在Mock数据里我们就可以自由控制。</p>
<h2 id="5-9-样式"><a href="#5-9-样式" class="headerlink" title="5.9 样式"></a>5.9 样式</h2><h3 id="（1）UI组件"><a href="#（1）UI组件" class="headerlink" title="（1）UI组件"></a>（1）UI组件</h3><p>项目的UI组件仍然选择了<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN">ElementUI</a>，对于ElementUI的引入应该采取按需引入的方式，尽可能减少构建后的体积。可以直接使用Element为Vue Cli@3提供的<a target="_blank" rel="noopener" href="https://github.com/ElementUI/vue-cli-plugin-element">插件</a>，它会帮助我们完成ElementUI的按需引入。</p>
<p>如果是手动安装的话需要安装<a target="_blank" rel="noopener" href="https://github.com/ElementUI/babel-plugin-component#readme"><code>babel-plugin-component</code></a>使用，安装之后在根目录下新建<code>.babel.config.js</code>文件（如果Vue CLI已经创建的话可以直接使用），然后在<code>plugins</code>中添加<code>element-ui</code>的使用）</p>
<p>然后在<code>/src/plugins/elemment.ts</code>中引入需要的Element组件，并将需要的方法（比如<code>$loading</code>挂载到Vue的原型上（不推荐挂载大量的属性到Vue原型上，会导致性能的下降）。</p>
<p>同时，ElementUI提供了<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/theme">主题定制</a>的功能，详细使用方法参考<a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/custom-theme">文档</a>。完成主题定制后，下载定制后的文件放到根目录下新建的<code>theme</code>目录内，然后在<code>.babel.config.js</code>添加<code>styleLibraryName</code>属性，指向<code>theme</code>目录，<code>.babel.config.js</code>完整的配置如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;@vue/cli-plugin-babel/preset&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;component&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;libraryName&quot;</span>: <span class="string">&quot;element-ui&quot;</span>,</span><br><span class="line">        <span class="string">&quot;styleLibraryName&quot;</span>: <span class="string">&quot;~theme&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在开发类似CRM的后台项目时，如果对样式有要求，尽量提前与UE&#x2F;UI同学进行沟通，基于ElementUI的组件规范进行样式定制，尽量避免通过覆盖样式的方式来修改ElementUI的内置组件的样式。</p>
</blockquote>
<h3 id="（2）样式规范"><a href="#（2）样式规范" class="headerlink" title="（2）样式规范"></a>（2）样式规范</h3><p>前面提到了，项目会使用Stylelint对样式的编写进行规范，同时还有一些规范要遵守：</p>
<ul>
<li>在Vue单文件组件内，除非极特殊的情况，<strong>都需要使用<code>scoped</code>属性</strong>，避免组件样式成为全局样式，污染全局样式，并且导致在开发或编译时组件间的样式相互干扰。</li>
<li>如果没有添加<code>scoped</code>属性，那么意味着你明确知晓并且意图将这个样式继承给子组件，但是前提是为这些样式添加了一个足够独一无二的类名。</li>
<li>另外，除非UI组件的要求，不允许使用内联样式</li>
<li>不允许使用ID选择器编写样式</li>
<li>除非极特殊情况，不允许使用<code>!important</code></li>
<li><code>class</code>命名使用<code>kebab-case</code>格式，例如<code>user-list-item</code></li>
</ul>
<blockquote>
<p>关于变量名：无论是CSS的类名还是JavaScript的变量名，在遵守格式要求的基础上（<code>PascalCase</code>或者<code>kebab-case</code>)尽可能传达出有效的信息，想<code>value1</code>、<code>value2</code>这样没有任何意义的命名要避免（除非是在具体的回调函数中有具体的上下文环境），使用带有足够信息量的变量名提高代码的可读性。使用英文命名，不要使用拼音。</p>
<p>另外，避免（！）语意不明或者是错误的缩写。</p>
</blockquote>
<h3 id="（3）自动导入全局样式变量"><a href="#（3）自动导入全局样式变量" class="headerlink" title="（3）自动导入全局样式变量"></a>（3）自动导入全局样式变量</h3><p>样式预处理器选择使用了Less，在<code>/src/styles</code>下面声明了一些全局的样式文件，目前有三个：</p>
<ul>
<li><code>reset.css</code>，用来重置浏览器默认样式</li>
<li><code>mixins.less</code>，用来实现一些可以传入参数的样式模块，比如文字剪切等，直接在组件样式中调用</li>
<li><code>variables.less</code>，用来定义一些全局的样式变量，比如主题颜色、边框颜色等等</li>
</ul>
<p>对于后两者，使用了<a target="_blank" rel="noopener" href="https://github.com/yenshih/style-resources-loader"><code>style-resources-loader</code></a>，让我们不需要手动导入这些全局的样式文件。需要在<code>vue.config.js</code>中进行配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">StyleLintPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;stylelint-webpack-plugin&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 自动导入样式文件</span></span><br><span class="line">    <span class="keyword">const</span> types = [<span class="string">&#x27;vue-modules&#x27;</span>, <span class="string">&#x27;vue&#x27;</span>, <span class="string">&#x27;normal-modules&#x27;</span>, <span class="string">&#x27;normal&#x27;</span>];</span><br><span class="line">    types.<span class="title function_">forEach</span>(<span class="function"><span class="params">type</span> =&gt;</span> <span class="title function_">addStyleResource</span>(config.<span class="property">module</span>.<span class="title function_">rule</span>(<span class="string">&#x27;less&#x27;</span>).<span class="title function_">oneOf</span>(type)));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">addStyleResource</span> (rule) &#123;</span><br><span class="line">  rule.<span class="title function_">use</span>(<span class="string">&#x27;style-resource&#x27;</span>)</span><br><span class="line">    .<span class="title function_">loader</span>(<span class="string">&#x27;style-resources-loader&#x27;</span>)</span><br><span class="line">    .<span class="title function_">options</span>(&#123;</span><br><span class="line">      <span class="attr">patterns</span>: [</span><br><span class="line">        path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src/styles/variables.less&#x27;</span>),</span><br><span class="line">        path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;./src/styles/mixins.less&#x27;</span>),</span><br><span class="line">      ],</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果后续需要导入更多的样式变量，那么只需要在<code>addStyleResource</code>的我<code>patterns</code>数组中添加对应的路径即可。</p>
<h2 id="5-10-环境变量和构建脚本"><a href="#5-10-环境变量和构建脚本" class="headerlink" title="5.10 环境变量和构建脚本"></a>5.10 环境变量和构建脚本</h2><p>根据不同的环境新建了几个<code>.env</code>文件，例如我们有线上（<code>production</code>）&#x2F;开发（<code>development</code>）&#x2F;测试（<code>staging</code>）三个环境，在各自的环境文件中（例如<code>.env.production</code>）配置<code>VUE_BASE_URL</code>等变量。</p>
<p>依赖管理工具选择了使用<a target="_blank" rel="noopener" href="https://yarn.bootcss.com/">Yarn</a>代替NPM，在<code>package.json</code>中的脚本除了常规的<code>serve</code>、<code>build</code>之外，还未编译的时候也创建对应的脚本，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve --open&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build --modern&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build-dev&quot;</span>: <span class="string">&quot;vue-cli-service build --modern --mode development&quot;</span>,</span><br><span class="line">  <span class="string">&quot;build-staging&quot;</span>: <span class="string">&quot;vue-cli-service build --modern --mode staging&quot;</span>,</span><br><span class="line">  <span class="string">&quot;test:unit&quot;</span>: <span class="string">&quot;vue-cli-service test:unit&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span>,</span><br><span class="line">  <span class="string">&quot;analyze&quot;</span>: <span class="string">&quot;vue-cli-service build --modern --report&quot;</span>,</span><br><span class="line">  <span class="string">&quot;preview&quot;</span>: <span class="string">&quot;cd dist &amp;&amp; npx http-server -a 127.0.0.1 -p 7000&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>另外，配置了<code>pre-commit</code>的钩子，在每次提交前都会对改动的文件进行代码格式和规范的检查，不通过本地也无法提交，这样就缩短了代码质量的反馈链，不必等到Icode检查半天才告诉你不符合规范。</p>
<h2 id="5-11-Code-Reivew"><a href="#5-11-Code-Reivew" class="headerlink" title="5.11 Code Reivew"></a>5.11 Code Reivew</h2><p>Code Reivew是一个可以提升团队代码质量的手段，更重要的是，它也可以提高自己的代码水平，无论是你Review他人的代码，还是被别人Review代码。</p>
<p>关于Code Reivew，提交代码时有如下几点建议：</p>
<ol>
<li>分节点提交代码（开始写之前做好规划），每次提交Reivew的代码不要过多</li>
<li>分批次Commit</li>
<li>清晰的Commit Message</li>
</ol>
<p>Review他人代码时：</p>
<ol>
<li>尽量抽出时间Review别人的代码</li>
<li>了解需求详情</li>
<li>首先关注高层次问题（例如接口设计、函数分解等）</li>
<li>多打-2</li>
</ol>
<h2 id="5-12-Todo"><a href="#5-12-Todo" class="headerlink" title="5.12 Todo"></a>5.12 Todo</h2><h3 id="（1）Axios-Vuex的全局缓存"><a href="#（1）Axios-Vuex的全局缓存" class="headerlink" title="（1）Axios + Vuex的全局缓存"></a>（1）Axios + Vuex的全局缓存</h3><p>前面提到了，需要考虑的问题：</p>
<ol>
<li>不需要每个请求（即<code>dispatch</code>每个Action）时都需要处理，那么也许将缓存这一部分与Axios的封装结合在一起比较好</li>
<li>为缓存添加可控制的属性，比如最大缓存时间、强制忽略缓存等</li>
<li>缓存控制的粒度，是以请求为粒度，还是URL作为更细的控制粒度？</li>
<li>当多个请求请求同一份资源的时候，后续请求如何处理？是直接忽略缓存发送多个请求（简单粗暴）？还是使用资源池配合监听订阅模式实现效率最大化（精致复杂）？</li>
</ol>
<h3 id="（2）接口超时自动重试"><a href="#（2）接口超时自动重试" class="headerlink" title="（2）接口超时自动重试"></a>（2）接口超时自动重试</h3><p>除了前面提到的，与Vuex的全局缓存相结合的问题，有时间再研究下接口超时自动重试的方案。</p>
<p>其实在JS版本的Vue项目中已经实现了接口自动重试的方案，但是TS版本中没有办法向Axios的配置对象中传入自定义的参数，所以不能自由的控制是否开启接口的自动重试，所以不太完美，而且这个需求也是低优的，再仔细考虑一下</p>
<blockquote>
<p>（2020.01.09更新）</p>
</blockquote>
<p>找到了<a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/10859">解决方案</a>，就是利用TypeScript的<a target="_blank" rel="noopener" href="https://nodelover.gitbook.io/typescript/sheng-ming-he-bing#ding-yi-can-shu-zhong-zai-de-zhu-yi-shi-xiang">声明合并</a>，为Axios的<code>AxiosRequestConfig</code>添加自定义的属性。具体解决方法时在根目录下创建一个<code>shims-cunstom.d.ts</code>文件，里面用来定制第三方模块的类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;axios&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">export</span> interface <span class="title class_">AxiosRequestConfig</span> &#123;</span><br><span class="line">    customProperty?: boolean;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span>;</span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>如果没有第一行，<code>axios.d.ts</code>中定义的接口就不会被合并进来，细节参考<a target="_blank" rel="noopener" href="http://www.typescriptlang.org/docs/handbook/declaration-merging.html#merging-namespaces">TypeScript的文档</a>吧</p>
<h3 id="（3）WebP图片引入"><a href="#（3）WebP图片引入" class="headerlink" title="（3）WebP图片引入"></a>（3）WebP图片引入</h3><p>WebP是Google推出的图片格式，相比于PNG、JPG能够在保证图片质量的同时，大幅减小图片的体积，<a target="_blank" rel="noopener" href="https://caniuse.com/#search=webp">兼容性</a>如下：</p>
<p><img src="http://image.oldzhou.cn/FkyWESp1wooznoBLa1K9wdS6MhXM"></p>
<p>IE系列和Safari系列的兼容性需要处理，所以需要在引入WebP的同时实现优雅降级。</p>
<h3 id="（4）异常监控和上报"><a href="#（4）异常监控和上报" class="headerlink" title="（4）异常监控和上报"></a>（4）异常监控和上报</h3><h3 id="（5）图片压缩"><a href="#（5）图片压缩" class="headerlink" title="（5）图片压缩"></a>（5）图片压缩</h3><h1 id="6-CLI工具"><a href="#6-CLI工具" class="headerlink" title="6 CLI工具"></a>6 CLI工具</h1><p>将上面基本的配置和实践抽离成为了一个模板<a target="_blank" rel="noopener" href="https://github.com/duola8789/vue-ts-template">vue-ts-template</a>，预置的功能可以看项目的介绍。使用的时候可以直接将这个仓库<code>clone</code>下来使用。</p>
<p>为了更方便的使用，我按照<a href="https://duola8789.github.io/2019/07/17/01%20%E5%89%8D%vue-ts-cliE7%AB%AF%E7%AC%94%E8%AE%B0/11%20%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B02%20%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6%E5%B7%A5%E5%85%B7/">以前的博客</a>，做了一个简单的CLI工具<a target="_blank" rel="noopener" href="https://github.com/duola8789/vue-ts-cli">vue-ts-cli</a>，并且发布到了<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vue-ts-cli-zh">NPM</a>上，可以更方便的拉取模板。</p>
<p>使用方法（推荐使用<code>npx</code>工具，需要<code>npm</code>版本高于5.2）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx vue-ts-cli-zh init [project_name]</span><br></pre></td></tr></table></figure>

<p><code>init</code>跟着的<code>project_name</code>就是新创建的项目所在的目录名。</p>
<h1 id="7-常见问题"><a href="#7-常见问题" class="headerlink" title="7 常见问题"></a>7 常见问题</h1><p>（1）<a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-7/#stricter-class-property-checks">Property ‘xxx’ has no initializer and is not definitely assigned in the constructor</a></p>
<p>这是因为声明的<code>xxx</code>变量没有对应的构造器（<code>initializer</code>）也就是没赋初值，有可能是<code>undefined</code>，所以需要进行非空的断言或者声明可能的<code>undefined</code>类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title class_">State</span> title!: string;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">@<span class="title class_">State</span> <span class="attr">title</span>: string | <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<p>（2）定义TS中的<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f78b2a294cc">Promise类型</a></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1（推荐）</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;number&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve: (value: number) =&gt; <span class="keyword">void</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="title function_">resolve</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>（3）无法在Vue组件中引入图片：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;@/assets/images/test.jpg&#x27;</span>;</span><br><span class="line"><span class="comment">// Error:(10, 18) TS2307: Cannot find module &#x27;@/assets/images/test.jpg&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>解决方法：在<code>./shims-vue.d.ts</code>文件中添加图片文件的类型声明：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">Vue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.png&#x27;</span>;</span><br><span class="line">declare <span class="variable language_">module</span> <span class="string">&#x27;*.jpg&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>（4）编译时去除<code>console</code></p>
<p>在Vue CLI2时直接在<code>./build/webpack.prod.conf.js</code>中配置即可：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">plugins</span>: [</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">UglifyJsPlugin</span>(&#123;</span><br><span class="line">    <span class="attr">uglifyOptions</span>: &#123;</span><br><span class="line">      <span class="attr">compress</span>: &#123;</span><br><span class="line">        <span class="attr">warnings</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">sourceMap</span>: config.<span class="property">build</span>.<span class="property">productionSourceMap</span>,</span><br><span class="line">    <span class="attr">parallel</span>: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>到了Vue CLI4压缩插件变成了内置的<a target="_blank" rel="noopener" href="https://github.com/webpack-contrib/terser-webpack-plugin"><code>terser-webpack-plugin</code></a>，它的默认配置是<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue-cli/blob/01e36f30cfbc82814cf0fea8da1c408667daa052/packages/%40vue/cli-service/lib/config/terserOptions.js#L39">这样</a>的，新的<a target="_blank" rel="noopener" href="https://cli.vuejs.org/migrating-from-v3/#vue-cli-service">配置方法</a>应该在<code>vue.config.js</code>中进行如下的配置：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">chainWebpack</span>: <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 编译时去除 console 和 debugger</span></span><br><span class="line">    <span class="keyword">if</span> (process.<span class="property">env</span>.<span class="property">NODE_ENV</span> !== <span class="string">&#x27;development&#x27;</span>) &#123;</span><br><span class="line">      config.<span class="property">optimization</span>.<span class="title function_">minimizer</span>(<span class="string">&#x27;terser&#x27;</span>).<span class="title function_">tap</span>(<span class="function">(<span class="params">args</span>) =&gt;</span> &#123;</span><br><span class="line">        args[<span class="number">0</span>].<span class="property">terserOptions</span>.<span class="property">compress</span>.<span class="property">drop_console</span> = <span class="literal">true</span>;</span><br><span class="line">        args[<span class="number">0</span>].<span class="property">terserOptions</span>.<span class="property">compress</span>.<span class="property">drop_debugger</span> = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> args</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a target="_blank" rel="noopener" href="http://www.wlxadyl.cn/2018/12/06/build-ts-vue/">搭建可用的Vue+TypeScript脚手架@卡少的沉淀博客</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/kaorun343/vue-property-decorator">kaorun343&#x2F;vue-property-decorator@Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ktsn/vuex-class">ktsn&#x2F;vuex-class</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/TypeStrong/fork-ts-checker-webpack-plugin#options">TypeStrong&#x2F;fork-ts-checker-webpack-plugin@Github</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/microsoft/TypeScript/issues/10859">Extend external modules declared in @types npm dependency #10859microsoft&#x2F;TypeScript</a></li>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/4f78b2a294cc">如何在Typescript中定义Promise的返回值类型@简书</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Vue/" rel="tag"># Vue</a>
              <a href="/tags/TypeScript/" rel="tag"># TypeScript</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/12/20/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/06%20Redux/Redux05%20Redux-Saga/" rel="prev" title="Redux05 Redux-Saga">
                  <i class="fa fa-chevron-left"></i> Redux05 Redux-Saga
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2020/03/27/03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/10%20%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%EF%BC%88%E4%B8%8A%E5%8D%B7%EF%BC%89/" rel="next" title="《你不知道的JavaScript（上卷）》读书笔记">
                  《你不知道的JavaScript（上卷）》读书笔记 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">多啦大薯片</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"duola8789/duola8789.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
