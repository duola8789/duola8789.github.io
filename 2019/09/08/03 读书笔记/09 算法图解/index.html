<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo-new.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css" integrity="sha256-Z1K5uhUaJXA7Ll0XrZ/0JhX4lAtZFpT6jkKrEDT0drU=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"duola8789.github.io","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.14.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《算法图解》读书笔记。">
<meta property="og:type" content="article">
<meta property="og:title" content="《算法图解》读书笔记">
<meta property="og:url" content="https://duola8789.github.io/2019/09/08/03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/09%20%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/index.html">
<meta property="og:site_name" content="不负时光">
<meta property="og:description" content="《算法图解》读书笔记。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://image.oldzhou.cn/1v.PNG">
<meta property="og:image" content="http://image.oldzhou.cn/zf12.PNG">
<meta property="og:image" content="http://image.oldzhou.cn/FiQoRiT8tz138jzvkeQZWRGEFw93">
<meta property="og:image" content="http://image.oldzhou.cn/Fl3iEnO5FYCdyYiMXiOkCuql1uUB">
<meta property="og:image" content="http://image.oldzhou.cn/Fj5dynDALXWgM5DB-qCJtK18Mo2T">
<meta property="og:image" content="http://image.oldzhou.cn/Fjx9eekL9ZyKlS4dZPQ7YUXbFg91">
<meta property="og:image" content="http://image.oldzhou.cn/FrfzqyPU7e18nxxgP9cvJMS8-lMX">
<meta property="og:image" content="http://image.oldzhou.cn/Fmr34MFG0USbDmNqmNeNu45ywTW4">
<meta property="og:image" content="http://image.oldzhou.cn/FmOxsuyNafgyhDN69YCLJ8YC1Msi">
<meta property="og:image" content="http://image.oldzhou.cn/FvFXMVoXNM9W8GcvZsU1Avfj7a79">
<meta property="og:image" content="http://image.oldzhou.cn/FvvBFCu23aMo0xK9UVTAsMvc_Xby">
<meta property="og:image" content="http://image.oldzhou.cn/FiYMEKJtqo2zeAaW1G5q6k44cnSk">
<meta property="og:image" content="http://image.oldzhou.cn/Fhi7juYF5NjIkAhkjGLRyRJmjXEW">
<meta property="og:image" content="http://image.oldzhou.cn/Fr0lFaLA3xhe7OYIv4ryvWPnq4dc">
<meta property="og:image" content="http://image.oldzhou.cn/FlF6aYs9sjSCCiJCpvBzZJ9C-WN-">
<meta property="og:image" content="http://image.oldzhou.cn/FiWlG9ksWIX1G_3GvJoiB8Ktmkxc">
<meta property="og:image" content="http://image.oldzhou.cn/Fn_k5y9H71yf44EpwYgcjm95SYIp">
<meta property="og:image" content="http://image.oldzhou.cn/Fqtw8x2bLAZf3bInFWPOy-ZLZwd6">
<meta property="article:published_time" content="2019-09-08T10:25:40.000Z">
<meta property="article:modified_time" content="2019-09-08T10:25:45.000Z">
<meta property="article:author" content="多啦大薯片">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://image.oldzhou.cn/1v.PNG">


<link rel="canonical" href="https://duola8789.github.io/2019/09/08/03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/09%20%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://duola8789.github.io/2019/09/08/03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/09%20%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/","path":"2019/09/08/03 读书笔记/09 算法图解/","title":"《算法图解》读书笔记"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>《算法图解》读书笔记 | 不负时光</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?383801e819a170224708308b7b4411a5"></script>







  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">不负时光</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">少年回头望，笑我还不快跟上</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-about"><a href="http://www.oldzhou.cn/pages/page1.html" rel="section" target="_blank"><i class="fa fa-user fa-fw"></i>关于</a></li>
  </ul>
</nav>




</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%AE%97%E6%B3%95%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">第一章 算法简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.1.</span> <span class="nav-text">二分查找</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4"><span class="nav-number">1.2.</span> <span class="nav-text">运行时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.3.</span> <span class="nav-text">大O表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.</span> <span class="nav-text">第二章 选择排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.1.</span> <span class="nav-text">内存的工作原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84"><span class="nav-number">2.2.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="nav-number">2.4.</span> <span class="nav-text">在中间插入元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">2.5.</span> <span class="nav-text">删除元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="nav-number">2.6.</span> <span class="nav-text">数组和链表的比较</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Facebook%E5%AD%98%E5%82%A8%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.7.</span> <span class="nav-text">Facebook存储用户信息的方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">2.8.</span> <span class="nav-text">选择排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%80%92%E5%BD%92"><span class="nav-number">3.</span> <span class="nav-text">第三章 递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E7%BA%BF%E6%9D%A1%E4%BB%B6%E5%92%8C%E9%80%92%E5%BD%92%E6%9D%A1%E4%BB%B6"><span class="nav-number">3.1.</span> <span class="nav-text">基线条件和递归条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88"><span class="nav-number">3.2.</span> <span class="nav-text">栈</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">第四章 快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">分治法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%A4%A7-O-%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">再谈大$O$表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">5.</span> <span class="nav-text">第五章 散列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">散列函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="nav-number">5.2.</span> <span class="nav-text">散列表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD"><span class="nav-number">5.3.</span> <span class="nav-text">性能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS"><span class="nav-number">6.</span> <span class="nav-text">第六章 广度优先搜索（BFS)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BE%E7%AE%97%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">图算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="nav-number">6.2.</span> <span class="nav-text">广度优先搜索</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">6.3.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95"><span class="nav-number">6.4.</span> <span class="nav-text">实现算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E9%97%B4-1"><span class="nav-number">6.5.</span> <span class="nav-text">运行时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-number">7.</span> <span class="nav-text">第七章 迪克斯特拉算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95"><span class="nav-number">7.1.</span> <span class="nav-text">使用迪克斯特拉算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="nav-number">7.2.</span> <span class="nav-text">负权边</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AA%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">7.3.</span> <span class="nav-text">迪克斯特拉算法的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95"><span class="nav-number">8.</span> <span class="nav-text">第八章 贪婪算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%99%E5%AE%A4%E8%B0%83%E5%BA%A6%E9%97%AE%E9%A2%98"><span class="nav-number">8.1.</span> <span class="nav-text">教室调度问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="nav-number">8.2.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="nav-number">8.3.</span> <span class="nav-text">集合覆盖问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95"><span class="nav-number">8.4.</span> <span class="nav-text">近似算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">8.5.</span> <span class="nav-text">NP完全问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E8%AF%86%E5%88%ABNP%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98"><span class="nav-number">8.6.</span> <span class="nav-text">如何识别NP完全问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">9.</span> <span class="nav-text">第九章 动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-1"><span class="nav-number">9.1.</span> <span class="nav-text">背包问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E5%81%B7%E5%95%86%E5%93%81%E7%9A%84%E4%B8%80%E9%83%A8%E5%88%86%E5%90%97"><span class="nav-number">9.2.</span> <span class="nav-text">可以偷商品的一部分吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E4%BB%A5%E7%9B%B8%E4%BA%92%E4%BE%9D%E8%B5%96%E5%90%97"><span class="nav-number">9.3.</span> <span class="nav-text">可以相互依赖吗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2"><span class="nav-number">9.4.</span> <span class="nav-text">最长公共子串</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="nav-number">9.5.</span> <span class="nav-text">最长公共子序列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">9.6.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95"><span class="nav-number">10.</span> <span class="nav-text">第十章 K最近邻算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F"><span class="nav-number">10.1.</span> <span class="nav-text">创建推荐系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0"><span class="nav-number">10.2.</span> <span class="nav-text">机器学习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%A6%82%E4%BD%95%E5%81%9A"><span class="nav-number">11.</span> <span class="nav-text">第十一章 接下来如何做</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">11.1.</span> <span class="nav-text">树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8D%E5%90%91%E7%B4%A2%E5%BC%95"><span class="nav-number">11.2.</span> <span class="nav-text">反向索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="nav-number">11.3.</span> <span class="nav-text">傅里叶变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MapReduce"><span class="nav-number">11.4.</span> <span class="nav-text">MapReduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%92%8CHyperLogLog"><span class="nav-number">11.5.</span> <span class="nav-text">布隆过滤器和HyperLogLog</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SHA%E7%AE%97%E6%B3%95"><span class="nav-number">11.6.</span> <span class="nav-text">SHA算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E6%98%8E%E6%9A%97%E7%9A%84%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95"><span class="nav-number">11.7.</span> <span class="nav-text">局部明暗的散列算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2"><span class="nav-number">11.8.</span> <span class="nav-text">Diffie-Hellman密钥交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92"><span class="nav-number">11.9.</span> <span class="nav-text">线性规划</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="多啦大薯片"
      src="/images/avatar3.png">
  <p class="site-author-name" itemprop="name">多啦大薯片</p>
  <div class="site-description" itemprop="description">欲买桂花同载酒，终不似，少年游</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">213</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">283</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/duola8789" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;duola8789" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:duola8789@126.com" title="E-Mail → mailto:duola8789@126.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/zhouhaozhouhao" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;zhouhaozhouhao" rel="noopener me" target="_blank"><i class="fab fa-weibo fa-fw"></i>Weibo</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/aisheishei2011" title="Douban → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;aisheishei2011" rel="noopener me" target="_blank"><i class="fa fa-book fa-fw"></i>Douban</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://duola8789.github.io/2019/09/08/03%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/09%20%E7%AE%97%E6%B3%95%E5%9B%BE%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar3.png">
      <meta itemprop="name" content="多啦大薯片">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="不负时光">
      <meta itemprop="description" content="欲买桂花同载酒，终不似，少年游">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="《算法图解》读书笔记 | 不负时光">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《算法图解》读书笔记
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2019-09-08 18:25:40 / 修改时间：18:25:45" itemprop="dateCreated datePublished" datetime="2019-09-08T18:25:40+08:00">2019-09-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26979890/">《算法图解》</a>读书笔记。</p>
<span id="more"></span>

<h2 id="第一章-算法简介"><a href="#第一章-算法简介" class="headerlink" title="第一章 算法简介"></a>第一章 算法简介</h2><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>二分查找是一种算法，其输入必须是<strong>有序</strong>的元素列表。</p>
<p>对于包含<code>n</code>个元素的列表，使用二分查找最多需要<code>$\log_2^n$</code>步</p>
<p>对数运算是幂运算的逆运算</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log_2^n = a  →  2^a=n</span><br></pre></td></tr></table></figure>

<p>在使用大O表示法讨论运行时间时，<code>$\log$</code>指的都是<code>$\log_2$</code>（以<code>2</code>为底）</p>
<p>二分法的JS实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分法查找</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">binarySearch</span> = (<span class="params">list, target</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> min = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> max = list.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (min &lt;= max) &#123;</span><br><span class="line">    <span class="keyword">const</span> middle = <span class="title class_">Math</span>.<span class="title function_">floor</span>((min + max) / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (list[middle] &gt; target) &#123;</span><br><span class="line">      max = middle - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list[middle] &lt; target) &#123;</span><br><span class="line">      min = middle + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> middle;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">binarySearch</span>([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], <span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<p>对于Python，如果取非整数索引，会自动向下取整，但是JS中不会，因为JS中的数组本质上是一个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0</span>: <span class="string">&#x27;x&#x27;</span>,</span><br><span class="line">  <span class="number">1</span>: <span class="string">&#x27;y&#x27;</span>,</span><br><span class="line">  <span class="attr">length</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以如果为JS数组的非整数索引赋值，结果如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">a[<span class="number">2.5</span>] = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"><span class="comment">// [1, 2, 2.5: 100]</span></span><br></pre></td></tr></table></figure>

<h3 id="运行时间"><a href="#运行时间" class="headerlink" title="运行时间"></a>运行时间</h3><p>线性时间：最多需要查找的次数与列表长度相同<code>$O(n)$</code></p>
<p>对数时间：最多需要查找的次数要<code>$\log_2^n$</code>, <code>$O(\log n)$</code></p>
<p><code>$O(\log n)$</code>比<code>$O(n)$</code>快，当需要搜索的元素越多，前者比后者快得就越多</p>
<h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>仅仅知道算法需要多长时间能运行完还不够，还需要知道运行时间如何随列表增长而增加。大O表示法表示的是算法运行时间的<strong>增速</strong>。</p>
<p>大O表示法指出的是<strong>最糟糕</strong>的情况下的运行时间。</p>
<p>一些常见的大O运行时间有：</p>
<ul>
<li><code>$O(\log n)$</code>，对数时间，例如二分查找</li>
<li><code>$O(n)$</code>，线性时间，例如简单查找</li>
<li><code>$O(n * \log n)$</code>，例如快速排序，一种比较快的排序算法</li>
<li><code>$O(n^2)$</code>，例如选择排序，一种比较慢的排序算法</li>
<li><code>$O(n!)$</code>，例如旅行商问题的解决方案，一种非常慢的算法</li>
</ul>
<p><img src="http://image.oldzhou.cn/1v.PNG" alt="image"></p>
<p>算法的速度指的并非时间，而是操作数的增速（随着输入的增加，运行时间将以什么样的速度增加）。</p>
<h2 id="第二章-选择排序"><a href="#第二章-选择排序" class="headerlink" title="第二章 选择排序"></a>第二章 选择排序</h2><h3 id="内存的工作原理"><a href="#内存的工作原理" class="headerlink" title="内存的工作原理"></a>内存的工作原理</h3><p>需要将数据存储到内存是，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式：数组和链表</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组所分配的内存空间都是紧紧相连的。如果为数组添加新元素时，当前数组占用的内存满了，则需要将数组元素转移到其他地方。可以预留内存，但是都会带来两个缺点：</p>
<ol>
<li>浪费内存</li>
<li>预留的内存用完后，还需要转移元素</li>
</ol>
<p>数组的优点：需要随机的读取元素时，数组效率很高。</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表中的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在了一起。</p>
<p>链表的优势在与插入元素方面，而且如果需要同时读取所有元素时，链表的效率很高。</p>
<h3 id="在中间插入元素"><a href="#在中间插入元素" class="headerlink" title="在中间插入元素"></a>在中间插入元素</h3><p>使用链表插入元素很简单，只需要修改它前面的额按个元素指向的地址。使用数组插入元素时，则必须将后面的所有元素都后移。</p>
<p>在中间插入元素，链表是更好的选择。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>需要删除元素，链表也是更好的选择。</p>
<h3 id="数组和链表的比较"><a href="#数组和链表的比较" class="headerlink" title="数组和链表的比较"></a>数组和链表的比较</h3><p>数组用的更多，因为它支持<strong>随机访问</strong>，所以数组的读取速度更快。而链表只能<strong>顺序访问</strong>。</p>
<p>数组和链表常见的操作的运行时间：</p>
<table>
<thead>
<tr>
<th>–</th>
<th>数组</th>
<th>链表</th>
</tr>
</thead>
<tbody><tr>
<td>读取</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>$O(n)$</code></td>
<td><code>$O(1)$</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>$O(n)$</code></td>
<td><code>$O(1)$</code></td>
</tr>
</tbody></table>
<h3 id="Facebook存储用户信息的方法"><a href="#Facebook存储用户信息的方法" class="headerlink" title="Facebook存储用户信息的方法"></a>Facebook存储用户信息的方法</h3><p>Facebook存储用户信息时用的是<strong>链表数组</strong>，数组包含26个元素，每个元素指向一个链表。</p>
<p><img src="http://image.oldzhou.cn/zf12.PNG" alt="image"></p>
<p>插入元素时，对数组的移动最多26次，然后再从它指向的链表中进行插入。</p>
<p>读取元素时，可以直接找到数组中的对应元素，然后在链表中查找。</p>
<blockquote>
<p>那么查找元素时，会不会效率太低？</p>
</blockquote>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序的原理就是每一轮在<code>n</code>个元素中进行查找，找出最小元素，放到结果当中。</p>
<p>每一轮的操作时间复杂度为<code>$O(n)$</code>，这样的操作需要执行<code>n</code>次，所以时间复杂度为<code>$O(n^2)$</code></p>
<p>有一个问题，每一轮进行后，下一轮要检查的元素会逐渐减少，实际随后检查的元素格式是一个公差为<code>1</code>的等差数列<code>n-1</code>、<code>n-2</code>…<code>2</code>、<code>1</code>，平均每次检查的元素是<code>n/2</code>，因此运行时间为<code>$O(n * n/2)$</code>，但是大O表示法会忽略诸如<code>1/2</code>这样的常数，所以为<code>$O(n^2)$</code></p>
<p>选择排序的JS实现：（从小到大排序）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">chooseSort</span> (arr) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i; j &lt; arr.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>选择排序的速度不是很快，快速排序的速度更快，时间复杂度为<code>$O(n * \log n)$</code></p>
<h2 id="第三章-递归"><a href="#第三章-递归" class="headerlink" title="第三章 递归"></a>第三章 递归</h2><p>递归是一种很多算法都使用的一种编程方法。</p>
<p>递归只是让解决方案更加清晰，并没有性能上的优势。实际上在有些情况下使用循环的性能更好。</p>
<h3 id="基线条件和递归条件"><a href="#基线条件和递归条件" class="headerlink" title="基线条件和递归条件"></a>基线条件和递归条件</h3><p>编写递归函数时，必须告诉它何时停止。每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件值得是函数不再调用自己，避免造成无限循环。</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种简单的数据结构，有两种操作：压入和弹出。</p>
<p>计算机内部使用被称为调用栈的栈。在调用过程中，调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都保留在内存中。</p>
<p>在递归调用栈中，包含着未完成的函数调用，自己无需跟踪哪些函数还没有被执行，栈会完成这个步骤。</p>
<p>使用栈很方便，但是也有性能代价，存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，那么以为这计算机储存了大量函数调用的信息。</p>
<p>解决方法：</p>
<ol>
<li>改用循环</li>
<li>使用尾递归（尾递归的实现需要确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数）</li>
</ol>
<h2 id="第四章-快速排序"><a href="#第四章-快速排序" class="headerlink" title="第四章 快速排序"></a>第四章 快速排序</h2><h3 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h3><p>分治法是解决问题的一种思路，一种递归式问题解决方法。</p>
<p>用分治法解决问题有包括两个步骤：</p>
<ol>
<li>找出基线条件（即递归终止的条件），这种条件必须尽可能简单</li>
<li>不断将问题分解（或者说缩小规模），直到符合基线条件</li>
</ol>
<p>一道题目：将一个长度为<code>length</code>、宽度为<code>width</code>的矩形均匀地分成方块，并确保分出的方块是最大的</p>
<p>分析这道题，首先要找出递归条件，最容易处理的情况是<strong>一条边的长度是另一条边的整数倍</strong>。这个时候就可以将矩形均匀地分成方块。</p>
<p>然后找出递归条件，每次递归都需要缩小问题规模。首先找出这块地可容纳的最大方块<code>A</code>，剩余的土地为<code>B</code>，根据欧几里得算法，适用于这小块地的最大方块，也是适用于整块地的最大的方块（就这个算法我就不知道，真做的时候就做出不来）。据此就可以不断的缩小规模，直到满足基线条件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到一个矩形可以均匀的划分的最大的小方块的尺寸</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getMaxSquare</span> = (<span class="params">length, width</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (width &gt; length) &#123;</span><br><span class="line">    [width, length] = [length, width]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length % width === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> width</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (length === width) &#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">getMaxSquare</span>(width, length - width)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>tips: 编写设计数组的递归函数时，基线条件通常是数组为空或者只包含一个元素。</p>
</blockquote>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快速排序的思想就是<strong>分治法</strong>，首先从最简单情况开始分析，找出基线条件，那就是数组为空或者只包含一个元素，然后逐渐增加到两个元素，三个元素。</p>
<p>到了三个元素的时候，首先选出基准值，然后分别找出比基准值小和比基准值大的元素（即分区），这样就得到了三个部分：</p>
<ol>
<li>小于基准值的数字组成的数组（无序）</li>
<li>基准值</li>
<li>大于基准值组成的数组（无序）</li>
</ol>
<p>然后对1和3再次进行快速排序，直到满足基线条件（即数组的长度为<code>0</code>或者<code>1</code>）为止。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">quickSort</span> = (<span class="params">arr</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> middleIndex = <span class="title class_">Math</span>.<span class="title function_">floor</span>(arr.<span class="property">length</span> / <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">const</span> middle = arr.<span class="title function_">splice</span>(middleIndex, <span class="number">1</span>)[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">const</span> left = [], right = [];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    (middle &gt; arr[i] ? left : right).<span class="title function_">push</span>(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">quickSort</span>(left).<span class="title function_">concat</span>(middle, <span class="title function_">quickSort</span>(right))</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>快速排序的时间复杂度是<code>$O(n * \log n)$</code></p>
<h3 id="再谈大-O-表示法"><a href="#再谈大-O-表示法" class="headerlink" title="再谈大$O$表示法"></a>再谈大<code>$O$</code>表示法</h3><p><code>c</code>是算法所需要的固定时间量，被称为常量。通常不考虑这个常量，因为如果算法的大<code>$O$</code>运行时间不同，这种常量将无关紧要。</p>
<p>但有时候，常量的影响可能很大，如果运行时间都是<code>$O(n * \log n)$</code>，那么常量就会影响很大。这也是快速排序比合并排序快的原因。</p>
<p>下面要分析一下，快速排序的时间复杂度为什么是<code>$O(n * \log n)$</code></p>
<p>快速排序的性能高度依赖于选择基准值，如果总是将第一个元素用作基准值，栈长为<code>n</code>（即总共要调用<code>n</code>次），每一轮要比较<code>n</code>个数字，每轮完成时间为<code>$O(n)$</code>，这就是最糟情况，这时候快速排序的运行时间是<code>$O(n^2)$</code></p>
<p>如果总是将中间的元素用作基准值，栈长变成了<code>$O(\log n)$</code>，每一轮仍然要比较<code>n</code>个数字，每轮完成时间为<code>$O(n)$</code>，这就是最佳情况，这时候快速排序的运行时间是<code>$O(n * \log n)$</code></p>
<p>要注意的是，最佳情况也是平均情况。只要每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间也就是<code>$O(n * \log n)$</code>。</p>
<p>快速排序是最快的排序算法之一，也是分治法的典范。</p>
<h2 id="第五章-散列表"><a href="#第五章-散列表" class="headerlink" title="第五章 散列表"></a>第五章 散列表</h2><h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>散列函数是这样的函数，无论输入什么数据，都还给一个数字，即将输入映射到数字，散列函数必须满足：</p>
<ol>
<li>每次输出的一致性</li>
<li>将不同的输入映射到不同的数字</li>
</ol>
<p>可以使用散列函数来确定元素的存储位置。</p>
<p>散列函数对于散列表的性能至关终于，良好的散列函数让数组中的值呈均匀分布，SHA函数可以用作散列函数。</p>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>使用散列函数和数组，就可以创建一种被称为散列表（hash table）的数据结构。</p>
<p>散列表也被称为散列映射、映射、字典和关联数组。适合用于：</p>
<ul>
<li>模拟映射关系</li>
<li>防止重复</li>
<li>缓存、记住数据</li>
</ul>
<p>JavaScript中的对象结构就是语言实现了的散列表结构。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>散列表的性能：</p>
<table>
<thead>
<tr>
<th>–</th>
<th>平均情况</th>
<th>最糟情况</th>
</tr>
</thead>
<tbody><tr>
<td>查找</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>插入</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
<tr>
<td>删除</td>
<td><code>$O(1)$</code></td>
<td><code>$O(n)$</code></td>
</tr>
</tbody></table>
<p>在平均情况下下，散列表执行各种操作的时间都是<code>$O(1)$</code>。<code>$O(1)$</code>被称为常量时间，它并不意味着马上，而是说不管散列表大多，所需的时间与长度无关，都是相同的数值。</p>
<p>所以在JavaScript中，使用对象存储数据并进行查找的性能大于使用数组存储，可以认为是<code>$O(1)$</code></p>
<h2 id="第六章-广度优先搜索（BFS"><a href="#第六章-广度优先搜索（BFS" class="headerlink" title="第六章 广度优先搜索（BFS)"></a>第六章 广度优先搜索（BFS)</h2><h3 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h3><p>广度优先搜索算法（breadth-first search，BFS）是一种图算法，可以找出两样东西之间最短的距离，即解决<strong>最短路径问题</strong>。</p>
<p>解决最短路径问题有两个步骤：</p>
<ol>
<li>使用图来建立问题模型</li>
<li>使用广度优先搜索解决问题</li>
</ol>
<p>图用来模拟不同的东西是如何连接的，由节点和边构成</p>
<p><img src="http://image.oldzhou.cn/FiQoRiT8tz138jzvkeQZWRGEFw93"></p>
<p>有向图的关系是单向的，边是箭头，箭头指定了关系的方向；无向图没有剪头，关系是双向的。</p>
<p><img src="http://image.oldzhou.cn/Fl3iEnO5FYCdyYiMXiOkCuql1uUB"></p>
<p>如果任务A依赖于任务B，在列表中任务A就必须在任务B后面，这被称为拓扑排序。</p>
<p><img src="http://image.oldzhou.cn/Fj5dynDALXWgM5DB-qCJtK18Mo2T"></p>
<p>树是一种特殊的图，其中没有往后指的边。</p>
<p><img src="http://image.oldzhou.cn/Fjx9eekL9ZyKlS4dZPQ7YUXbFg91"></p>
<h3 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h3><p>广度优先搜索是一种用于图的查找算法，可以解决两类问题：</p>
<ol>
<li>从节点A出发，有前往节点B的路径吗</li>
<li>从节点A出发，前往节点B的哪条路径最短</li>
</ol>
<p>在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径，但是一定要<strong>按添加顺序检查</strong>，队列（queue）是一种可以实现这种目的的数据结构。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列只支持两种操作：入队和出队。队列是一种<strong>先进先出</strong>（First In First Out）的数据结构，而栈是一种后进先出（Last In Frist Out）的数据结构。</p>
<h3 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h3><p>实现广度优先搜索的关键是，要使用队列来存放要搜索的结果，这个队列是在搜索的过程中不断变增加的。在遍历一层时，如果不是目标，则将这个元素的后代加入到待搜索队列中。同时使用一个对象标记对象是否已经遍历过（针对无向图，防止无限循环出现，对于树结构来说则不需要）</p>
<p>如果是实现最短路径，在将后代元素加入到待搜索队列中时，应该以对象的形式加入，因为要补充一个队列，用来存放当前遍历的路径。</p>
<h3 id="运行时间-1"><a href="#运行时间-1" class="headerlink" title="运行时间"></a>运行时间</h3><p>在整个关系网中进行搜索，以图算法来看，运行时间至少为<code>$O(边数)$</code>，此外还使用了一个队列来存放待搜索元素，将一个元素添加到队列的时间是固定的为<code>$O(1)$</code>，对每个元素都这样做的总时间为<code>$O(n)$</code>。</p>
<p>所以广度优先搜索的运行时间为<code>$O(边数+顶点数)$</code>，通常写作<code>$O(V+E)$</code>，<code>V</code>是顶点数，<code>E</code>是边数。</p>
<h2 id="第七章-迪克斯特拉算法"><a href="#第七章-迪克斯特拉算法" class="headerlink" title="第七章 迪克斯特拉算法"></a>第七章 迪克斯特拉算法</h2><p>广度优先搜索找出的是段数最少的路径，如果每段路径有着不同的权重，要找出最快的路径，可以使用迪克斯特拉算法</p>
<h3 id="使用迪克斯特拉算法"><a href="#使用迪克斯特拉算法" class="headerlink" title="使用迪克斯特拉算法"></a>使用迪克斯特拉算法</h3><p>迪克斯特拉算法包含四个步骤</p>
<ol>
<li>找出“最便宜”的节点，即可在最短时间内到达的节点</li>
<li>更新该节点的邻居的开销</li>
<li>重复这个过程，直到对图中每个节点都这样做了</li>
<li>计算最终路径</li>
</ol>
<p>迪克斯特拉算法背后的关键理念：<strong>找出图中最便宜的节点，确保没有到该节点的更便宜的路径</strong></p>
<h3 id="负权边"><a href="#负权边" class="headerlink" title="负权边"></a>负权边</h3><p><strong>如果有负权边，就不能使用迪克斯特拉算法</strong>。</p>
<p>因为节点一旦被处理，就以为这没有前往该节点的更便宜的路径，但是如果有负权边，那么就会在最片的路径被发现后，在负权边的路径上发现更便宜的节点。</p>
<p>在有负权边的图中，要找出最短路径，可以使用贝尔曼-福德算法。</p>
<h3 id="迪克斯特拉算法的实现"><a href="#迪克斯特拉算法的实现" class="headerlink" title="迪克斯特拉算法的实现"></a>迪克斯特拉算法的实现</h3><p>迪克斯特拉算法的实现需要四个散列表：</p>
<ol>
<li>用于存储节点、节点的邻居以及前往节点邻居的开销<code>graph</code></li>
<li>用于存储每个节点的最短开销<code>costs</code></li>
<li>用于存储每个节点最短开销情况下的父节点<code>parents</code></li>
<li>用于存储已经遍历过的节点<code>processed</code></li>
</ol>
<p>实际上上面这四个散列表就是迪克斯特拉算法需要的数据结构，需要将图转换为对应的数据结构后，对这种特定的数据结构使用算法，达到目的。</p>
<p>以下面的图距离：</p>
<p><img src="http://image.oldzhou.cn/FrfzqyPU7e18nxxgP9cvJMS8-lMX"></p>
<p>首先实现第一个散列表（也就是JS中的对象）<code>graph</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储节点、节点的邻居以及前往节点邻居的开销</span></span><br><span class="line"><span class="keyword">const</span> graph = &#123;</span><br><span class="line">  <span class="attr">start</span>: &#123;<span class="attr">a</span>: <span class="number">5</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="attr">a</span>: &#123;<span class="attr">c</span>: <span class="number">4</span>, <span class="attr">d</span>: <span class="number">2</span>&#125;,</span><br><span class="line">  <span class="attr">b</span>: &#123;<span class="attr">a</span>: <span class="number">8</span>, <span class="attr">d</span>: <span class="number">7</span>&#125;,</span><br><span class="line">  <span class="attr">c</span>: &#123;<span class="attr">d</span>: <span class="number">6</span>, <span class="attr">end</span>: <span class="number">3</span>&#125;,</span><br><span class="line">  <span class="attr">d</span>: &#123;<span class="attr">end</span>: <span class="number">1</span>&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后实现第二个对象<code>costs</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储每个节点的最短开销</span></span><br><span class="line"><span class="keyword">const</span> costs =  &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">5</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">  <span class="attr">d</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">  <span class="attr">end</span>: <span class="title class_">Infinity</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，没有计算的节点的开销用了<code>Infinity</code>无穷大来表示。</p>
<p>然后实现第三个对象<code>parents</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于存储每个节点最短开销情况下的父节点</span></span><br><span class="line"><span class="keyword">const</span> parents = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;start&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="string">&#x27;start&#x27;</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">d</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">end</span>:<span class="string">&#x27;&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第四个对象可以在函数内部声明一个对象实现，也可以直接改造第二个对象，添加一个是否遍历的属性。</p>
<p>构造数据结构完成之后，来实现<code>dijkstra</code>算法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到开销最小的，并且没有遍历过的节点</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">findLowestCostNode</span> = (<span class="params">costs, processed</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 筛选出没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">const</span> unProcessed = <span class="title class_">Object</span>.<span class="title function_">keys</span>(costs).<span class="title function_">filter</span>(<span class="function"><span class="params">key</span> =&gt;</span> !processed[key]);</span><br><span class="line">  <span class="comment">// 如果存在没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">if</span> (unProcessed &amp;&amp; unProcessed.<span class="property">length</span> &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 找出开销最小的节点</span></span><br><span class="line">    <span class="keyword">return</span> unProcessed.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> costs[a] - costs[b])[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不存在没有遍历过的节点时</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成加权图中的最短路径</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getFullPath</span> = parents =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> key = <span class="string">&#x27;end&#x27;</span>;</span><br><span class="line">  <span class="keyword">let</span> path = [];</span><br><span class="line">  <span class="keyword">while</span> (key !== <span class="string">&#x27;start&#x27;</span>) &#123;</span><br><span class="line">    path.<span class="title function_">unshift</span>(key);</span><br><span class="line">    key = parents[key];</span><br><span class="line">  &#125;</span><br><span class="line">  path.<span class="title function_">unshift</span>(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">  <span class="keyword">return</span> path.<span class="title function_">join</span>(<span class="string">&#x27;→&#x27;</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迪科特斯拉算法</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">dijkstra</span> = (<span class="params">graph, costs, parents</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 记录所有遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> processed = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 找到开销最小的，并且没有遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> node = <span class="title function_">findLowestCostNode</span>(costs, processed);</span><br><span class="line">  <span class="comment">// while 循环在所有节点都遍历过后结束</span></span><br><span class="line">  <span class="keyword">while</span> (node) &#123;</span><br><span class="line">    <span class="comment">// 找到当前节点的所有相邻节点</span></span><br><span class="line">    <span class="keyword">let</span> neighbors = graph[node];</span><br><span class="line">    <span class="comment">// 找到到达当前节点的开销</span></span><br><span class="line">    <span class="keyword">let</span> cost = costs[node];</span><br><span class="line">    <span class="comment">// 对所有相邻节点进行遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> neighborNode <span class="keyword">in</span> neighbors) &#123;</span><br><span class="line">      <span class="comment">// for...in 的安全性检查</span></span><br><span class="line">      <span class="keyword">if</span> (neighbors.<span class="title function_">hasOwnProperty</span>(neighborNode)) &#123;</span><br><span class="line">        <span class="comment">// 找出新的到达相邻节点的开销</span></span><br><span class="line">        <span class="keyword">const</span> newCost = cost + neighbors[neighborNode];</span><br><span class="line">        <span class="comment">// 如果计算出的新的开销小于已记录的开销，则进行更新</span></span><br><span class="line">        <span class="keyword">if</span> (newCost &lt; costs[neighborNode]) &#123;</span><br><span class="line">          <span class="comment">// 更新开销</span></span><br><span class="line">          costs[neighborNode] = newCost;</span><br><span class="line">          <span class="comment">// 更新父节点</span></span><br><span class="line">          parents[neighborNode] = node;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将当前节点标记为已经处理过</span></span><br><span class="line">    processed[node] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 找出接下来要处理的节点，并循环，直到所有节点都被处理过</span></span><br><span class="line">    node = <span class="title function_">findLowestCostNode</span>(costs, processed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回最终的开销和路径</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">cost</span>: costs[<span class="string">&#x27;end&#x27;</span>],</span><br><span class="line">    <span class="attr">path</span>: <span class="title function_">getFullPath</span>(parents),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>计算结果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">cost</span>: <span class="number">8</span>, <span class="attr">path</span>: <span class="string">&#x27;start→a→d→end&#x27;</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="第八章-贪婪算法"><a href="#第八章-贪婪算法" class="headerlink" title="第八章 贪婪算法"></a>第八章 贪婪算法</h2><h3 id="教室调度问题"><a href="#教室调度问题" class="headerlink" title="教室调度问题"></a>教室调度问题</h3><p>教室调度问题可以采用贪婪算法，具体做法如下：</p>
<ol>
<li>选出最早结束的课</li>
<li>选择第一堂课结束后的，并且结束最早的课</li>
<li>重复上面的步骤</li>
</ol>
<p>贪婪算法很简单：<strong>每一步都采取最优的做法</strong>。每步都选择局部最优解，最终得到的就是全局最优解。</p>
<h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p>对于背包问题，贪婪算法显然不能获得最优解。些时只需要找到一个能够大致解决问题的算法，此时贪婪算法刚好可以派上用场，因为它们实现起来很容易，得到的结果由于正确结果相当接近。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 贪婪算法求解背包问题近似解</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">knapsackProblem</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> bagSize = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;sound&#x27;</span>, <span class="attr">size</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;laptop&#x27;</span>, <span class="attr">size</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;guitar&#x27;</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">1500</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;iphone&#x27;</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> value = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> names = [];</span><br><span class="line">  <span class="keyword">let</span> remainSize = bagSize;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从价值最大的开始装，能装多少算多少</span></span><br><span class="line">  items.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b.<span class="property">value</span> - a.<span class="property">value</span>).<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.<span class="property">size</span> &lt;= remainSize) &#123;</span><br><span class="line">      value += v.<span class="property">value</span>;</span><br><span class="line">      names.<span class="title function_">push</span>(v.<span class="property">name</span>);</span><br><span class="line">      remainSize = remainSize - v.<span class="property">size</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    value, names</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="集合覆盖问题"><a href="#集合覆盖问题" class="headerlink" title="集合覆盖问题"></a>集合覆盖问题</h3><p>假设需要将一个广播节目让全美50个州的听众都收听得到，需要在尽可能少的广播台播出，这就是集合覆盖问题。</p>
<p>解决覆盖问题非常难，具体方法如下：</p>
<ol>
<li>列出每个可能的广播台的集合，被称为幂集，可能的子集有<code>$O(2^n)$</code>个</li>
<li>在这些集合中，选出覆盖全部50个州的最小集合</li>
</ol>
<p>运行时间为<code>$O(2^n)$</code>，需要一种近似算法</p>
<h3 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h3><p><strong>使用贪婪算法可以得到非常近似的解</strong>：</p>
<ol>
<li>选出这样一个广播台，它覆盖了最多的未覆盖州（即便这个广播台覆盖了一些已覆盖的州，也没有关系）</li>
<li>重复第一步，直到覆盖了所有的州</li>
</ol>
<p>这是一种近似算法，在获得精确解需要的时间太长时，可以使用近似算法。判断近似算法优劣的标准如下：</p>
<ol>
<li>速度有多快</li>
<li>得到的近似解与最优解的接近程度</li>
</ol>
<p>这个例子的贪婪算法的时间复杂度为<code>$O(n^2)$</code>，其中<code>n</code>是广播台的数量。</p>
<p>这种算法的关键是求出<code>statesNeeded</code>（需要覆盖的州）和<code>stateForStation</code>（电台能够覆盖的州）的交集，求出的就是当前广播电台覆盖的所有还未覆盖的州。</p>
<p>在所有没有选择的电台中进行比那里，找出上面提到的交集最大的电台。不断重复这个过程，直到所有的州都被覆盖为止。</p>
<h3 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h3><p>为了解决集合覆盖问题，你必须计算每个可能的集合，这与旅行商问题相似，需要计算每条可能的路径。</p>
<ul>
<li>当有<code>1</code>个城市时，可能的路线有<code>1</code>条</li>
<li>当有<code>2</code>个城市时，可能的路由先<code>2</code>条</li>
<li>当有<code>3</code>个城市时，可能的路由先<code>6</code>条</li>
<li>当有<code>4</code>个城市时，可能的路由先<code>24</code>条</li>
</ul>
<p>规律就是，每增加一个城市，需要计算的路线数都将增加，可以认为增加一个城市，可能的路径就以任何一个城市为起点（<code>n</code>）个，重复前一种情况的可能的路径数，也就是说当有<code>5</code>个城市时，任选一个作为起点，有<code>5</code>种情况，都是「当有<code>4</code>个城市时」的路径树<code>24</code>，也就是<code>24</code>重复了<code>5</code>遍，也就是<code>120</code>条</p>
<p>这是阶乘函数，如果涉及到的城市非常多，根本就无法找出旅行商问题的正确解。</p>
<p>旅行商问题和集合覆盖问题有一些共同之处：需要计算所有的解，并从中选出最小&#x2F;最短的那一个。这两个问题都属于NP完全问题。</p>
<p>旅行商问题的近似求解：随便选择出发城市，然后选择要去的下一个城市时，都选择还没去的最近的城市。选择的路径可能不是最短的，但是也比较接近了。</p>
<h3 id="如何识别NP完全问题"><a href="#如何识别NP完全问题" class="headerlink" title="如何识别NP完全问题"></a>如何识别NP完全问题</h3><p>判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。可以通过以下几点来判断NP完全问题：</p>
<ul>
<li>元素较少时算法的运行速度非常快，但随着元素数量增加，速度会变得非常慢</li>
<li>涉及“所有组合”的问题通常是NP完全问题</li>
<li>不能将问题分成小问题，必须考虑各种可能的情况，这可能是NP完全问题</li>
<li>如果问题涉及序列（如旅行商问题的城市序列）且难以解决，它可能就是NP完全问题</li>
<li>如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题</li>
<li>如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题</li>
</ul>
<h2 id="第九章-动态规划"><a href="#第九章-动态规划" class="headerlink" title="第九章 动态规划"></a>第九章 动态规划</h2><p>动态规划可以在给定约束条件下找到最优解。<strong>在问题可以分解为彼此独立且离散的子问题</strong>时，就可以使用动态规划来解决。</p>
<p><strong>为动态规划问题建模时的小窍门</strong>：</p>
<ul>
<li>每种动态规划解决方案都涉及网格</li>
<li>单元格中的值通常就是要优化的值</li>
<li>每个单元格都是一个子问题</li>
</ul>
<p>在绘制网格时，需要回答如下问题：</p>
<ul>
<li>单元格中的值是什么</li>
<li>如何将这个问题划分为子问题</li>
<li>网格的坐标轴是什么</li>
</ul>
<p>要注意，最终答案不一定在最后一个单元格中。</p>
<h3 id="背包问题-1"><a href="#背包问题-1" class="headerlink" title="背包问题"></a>背包问题</h3><p>背包问题就是典型的动态规划的应用之一。</p>
<p><strong>动态规划先解决子问题，在逐步解决大问题</strong>。每个动态规划算法都从一个网格开始，背包问题的网格如下：</p>
<p><img src="http://image.oldzhou.cn/Fmr34MFG0USbDmNqmNeNu45ywTW4"></p>
<p>填充的过程是逐行进行的，原则是<strong>保证当前单元格的值为此列的最大值</strong>。如果装入当前单元格的物品后，重量有剩余，则回退一行，找到剩余重量对应的最大值。</p>
<p>使用的公式为：</p>
<p><img src="http://image.oldzhou.cn/FmOxsuyNafgyhDN69YCLJ8YC1Msi"></p>
<p><strong>通过表格求解子问题，可以合并两个子问题的解来得到更大问题的解</strong>。</p>
<p>下面编写代码：</p>
<p>（感觉这个代码是为了这个算法生凑出来的，其实关键点把握住就行了，一是上面的公式，而是通过求解子问题，然后通过合并来求解更大问题）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">knapsackProblem</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> bagSize = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">const</span> items = [</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;sound&#x27;</span>, <span class="attr">size</span>: <span class="number">4</span>, <span class="attr">value</span>: <span class="number">3000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;laptop&#x27;</span>, <span class="attr">size</span>: <span class="number">3</span>, <span class="attr">value</span>: <span class="number">2000</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">name</span>: <span class="string">&#x27;guitar&#x27;</span>, <span class="attr">size</span>: <span class="number">1</span>, <span class="attr">value</span>: <span class="number">1500</span>&#125;,</span><br><span class="line">  ];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储结果的表格</span></span><br><span class="line">  <span class="keyword">const</span> cell = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 空格子</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">CellClass</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">0</span>;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">names</span> = [];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 外层遍历物品</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 声明新的一行</span></span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="comment">// 针对的物品</span></span><br><span class="line">    <span class="keyword">const</span> item = items[i];</span><br><span class="line">    <span class="comment">// 当前商品的价值</span></span><br><span class="line">    <span class="keyword">const</span> currentValue = item.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层遍历重量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt;= bagSize; j++) &#123;</span><br><span class="line">      <span class="comment">// 当前格子装入物品后的剩余空间</span></span><br><span class="line">      <span class="keyword">const</span> remainSize = j - item.<span class="property">size</span>;</span><br><span class="line">      <span class="comment">// 上一个单元格</span></span><br><span class="line">      <span class="keyword">const</span> lastCell = (cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j]) ? cell[i - <span class="number">1</span>][j] : <span class="keyword">new</span> <span class="title class_">CellClass</span>();</span><br><span class="line">      <span class="comment">// 上一个单元格的值（之前的最大值）</span></span><br><span class="line">      <span class="keyword">const</span> lastCellValue = lastCell.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果能装下这个物品</span></span><br><span class="line">      <span class="keyword">if</span> (remainSize &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 剩余空间对应的单元格</span></span><br><span class="line">        <span class="keyword">const</span> remainCell = (cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][remainSize]) ?cell[i - <span class="number">1</span>][remainSize]: <span class="keyword">new</span> <span class="title class_">CellClass</span>();</span><br><span class="line">        <span class="comment">// 剩余空间的价值</span></span><br><span class="line">        <span class="keyword">const</span> remainValue = remainCell.<span class="property">value</span>;</span><br><span class="line">        <span class="comment">// 预期的最大值</span></span><br><span class="line">        <span class="keyword">const</span> currentMaxValue = currentValue + remainValue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果预期的最大值更大</span></span><br><span class="line">        <span class="keyword">if</span> (currentMaxValue &gt; lastCellValue) &#123;</span><br><span class="line">          cell[i][j] = &#123;<span class="attr">value</span>: currentMaxValue, <span class="attr">names</span>: [item.<span class="property">name</span>, ...remainCell.<span class="property">names</span>]&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cell[i][j] = &#123;<span class="attr">value</span>: lastCellValue, <span class="attr">names</span>: lastCell.<span class="property">names</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 装不下这个物品则取上一个单元格</span></span><br><span class="line">        cell[i][j] = lastCell</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(cell);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> cell[items.<span class="property">length</span> - <span class="number">1</span>][bagSize]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="可以偷商品的一部分吗"><a href="#可以偷商品的一部分吗" class="headerlink" title="可以偷商品的一部分吗"></a>可以偷商品的一部分吗</h3><p>偷商品的一部分，不能使用动态规划处理。动态规划只能处理要么拿走整件商品，要么就不拿的情况，没法判断该不该拿走商品的一部分。</p>
<p>这种情况应该使用贪婪算法来处理，首先尽可能多的拿价值高的商品，如果拿光了在尽可能拿价值次高的商品，以此类推。</p>
<h3 id="可以相互依赖吗"><a href="#可以相互依赖吗" class="headerlink" title="可以相互依赖吗"></a>可以相互依赖吗</h3><p>如果各个项目之间有依赖情况，那么是没有办法使用动态规划来建模的。</p>
<p>动态规划算法能够解决子问题，并且使用这些答案来解决大问题。但是<strong>仅当每个子问题都是离散的，即不依赖于其他子问题时</strong>，动态规划才管用。</p>
<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p>在填充表格时，没有找出计算公式的简单办法，必须通过尝试才能找出有效的公式。<strong>有些算法并非精确的解决步骤，而是帮助你理清思路的框架</strong>。</p>
<p>在计算<code>FISH</code>和<code>HISH</code>的最大公共子串时，填写出来的表格和计算公式是：</p>
<p><img src="http://image.oldzhou.cn/FvFXMVoXNM9W8GcvZsU1Avfj7a79"></p>
<p>实现的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">maxSubstring</span> = (<span class="params">string1, string2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">string</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">let</span> cell = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; string2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (string1[i] === string2[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        cell[i][j] = &#123;</span><br><span class="line">          <span class="attr">value</span>: lastCell ? lastCell.<span class="property">value</span> + <span class="number">1</span> : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">string</span>: lastCell ? lastCell.<span class="property">string</span> + string1[i] : string1[i]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cell[i][j] = &#123;<span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">&#x27;&#x27;</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (result.<span class="property">value</span> &lt; cell[i][j].<span class="property">value</span>) &#123;</span><br><span class="line">        result.<span class="property">value</span> = cell[i][j].<span class="property">value</span>;</span><br><span class="line">        result.<span class="property">string</span> = cell[i][j].<span class="property">string</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以用这个算法来解决之前遇到过的<a href="https://duola8789.github.io/2018/12/04/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/01%20%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A0/%E5%89%8D%E7%AB%AF%E7%BB%83%E4%B9%A010%20%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E6%9C%80%E5%A4%A7%E5%92%8C/">《前端练习10 连续子串最大和</a>》的问题，具体分析过程看那篇笔记吧。</p>
<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>与最长公共子串不同，最长公共子序列不需要是连续的，比如<code>FOSH</code>与<code>FISH</code>的最长公共子串是<code>SH</code>，长度是<code>2</code>，而最长公共子序列是<code>FSH</code>，长度是<code>3</code></p>
<p>这个问题在计算单元格数据时使用的公式与最长子串不同：</p>
<p><img src="http://image.oldzhou.cn/FvvBFCu23aMo0xK9UVTAsMvc_Xby"></p>
<p>代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最长公共子序列</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">maxSubsequence</span> = (<span class="params">string1, string2</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> result = &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">string</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> cell = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; string1.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    cell[i] = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; string2.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (string1[i] === string2[j]) &#123;</span><br><span class="line">        <span class="keyword">const</span> lastCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        cell[i][j] = &#123;</span><br><span class="line">          <span class="attr">value</span>: lastCell ? (lastCell.<span class="property">value</span> + <span class="number">1</span>) : <span class="number">1</span>,</span><br><span class="line">          <span class="attr">string</span>: lastCell ? (lastCell.<span class="property">string</span> + string1[i]) : string1[i],</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 更新结果</span></span><br><span class="line">        <span class="keyword">if</span>(cell[i][j].<span class="property">value</span> &gt; result.<span class="property">value</span>) &#123;</span><br><span class="line">          result = cell[i][j]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> lastRowCell = cell[i] &amp;&amp; cell[i][j - <span class="number">1</span>] || &#123; <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">&#x27;&#x27;</span>,&#125;;</span><br><span class="line">        <span class="keyword">const</span> lastColCell = cell[i - <span class="number">1</span>] &amp;&amp; cell[i - <span class="number">1</span>][j]|| &#123; <span class="attr">value</span>: <span class="number">0</span>, <span class="attr">string</span>: <span class="string">&#x27;&#x27;</span>,&#125;;</span><br><span class="line">        <span class="keyword">if</span> (lastRowCell.<span class="property">value</span> &gt; lastColCell.<span class="property">value</span>) &#123;</span><br><span class="line">          cell[i][j] = &#123;</span><br><span class="line">            <span class="attr">value</span>: lastRowCell.<span class="property">value</span>,</span><br><span class="line">            <span class="attr">string</span>: lastRowCell.<span class="property">string</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cell[i][j] = &#123;</span><br><span class="line">            <span class="attr">value</span>: lastColCell.<span class="property">value</span>,</span><br><span class="line">            <span class="attr">string</span>: lastColCell.<span class="property">string</span>,</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>需要在给定约束条件下优化某种指标时，动态规划很有用</li>
<li>问题可以分解为离散的子问题时，可以使用动态规划来解决</li>
<li>每种动态规划解决方案都涉及网格</li>
<li>单元格中的值通常是你要优化的值</li>
<li>每个单元格都是一个子问题，需要考虑如何将问题分解为子问题</li>
<li>没有放之四海而皆准的计算动态规划解决方案的公式</li>
</ul>
<h2 id="第十章-K最近邻算法"><a href="#第十章-K最近邻算法" class="headerlink" title="第十章 K最近邻算法"></a>第十章 K最近邻算法</h2><p>K最近邻算法（k-nearest neighbours, KNN）简单的说就是在对一个事物分类时，如果自身没有准确的特征值用来分类，就可以看距离它最近的邻居，借此对目标分类。</p>
<h3 id="创建推荐系统"><a href="#创建推荐系统" class="headerlink" title="创建推荐系统"></a>创建推荐系统</h3><p>（1）特征抽取</p>
<p>要比较推荐系统的用户，就需要以某种方式将他们放到图表中，需要将每个用户转换为这一组坐标，然后就可以计算他们的距离了。</p>
<p>特征抽取就是将物品转换为一系列可比较的数字。</p>
<p>一种抽取特征值的方法：</p>
<p><img src="http://image.oldzhou.cn/FiYMEKJtqo2zeAaW1G5q6k44cnSk"></p>
<p>通过这些特征值可以计算距离：</p>
<p><img src="http://image.oldzhou.cn/Fhi7juYF5NjIkAhkjGLRyRJmjXEW"></p>
<p>（2）回归</p>
<p>所谓回归，就是使用KNN来做两项基本工作：分类和回归：</p>
<ul>
<li>分类就是编组</li>
<li>回归就是预测结果（比如一个数字）</li>
</ul>
<p>比如，找出与目标最接近的5个邻居，求这些人的平均分，就是回归。</p>
<p>可以使用余弦相似度来代替距离公式，能够更准确的找出相似的邻居。</p>
<p>（3）挑选合适的特征值没有通用的准则，必须考虑各种需要考虑的因素</p>
<p>能够挑选合适的特征事关KNN算法的成败。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>刚才的推荐系统实际上就是一个机器学习的例子，还有其他机器学习的例子</p>
<p>（1）OCR，光学字符识别，要自动识别字符，可以使用KNN</p>
<ul>
<li>浏览大量的图像，将这些数字的特征提取出来（也就是训练）</li>
<li>遇到新图像时提取该图像的特征，再找出它最近的邻居</li>
</ul>
<p>大多数及其学习算法都包含训练的步骤，要让计算机完成任务，必须先训练它</p>
<p>（2）垃圾邮件过滤器</p>
<p>垃圾邮件过滤器使用了一种简单算法：朴素贝叶斯分类器，用数据对分类器进行训练后，收到新的邮件，分析邮件中每个单词在垃圾邮件中出现的概率是多少</p>
<h2 id="第十一章-接下来如何做"><a href="#第十一章-接下来如何做" class="headerlink" title="第十一章 接下来如何做"></a>第十一章 接下来如何做</h2><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>二叉树查找（binary search tree，BST）的特征：</p>
<ol>
<li>左子树的所有节点的值都小于或等于它的根节点的值</li>
<li>右子树上所有节点的值均大于或等于它的根节点的值</li>
</ol>
<p>下面就是一棵典型的二叉查找树：</p>
<p><img src="http://image.oldzhou.cn/Fr0lFaLA3xhe7OYIv4ryvWPnq4dc"></p>
<p>在利用二叉查找树查找节点时的思想就是<strong>二分法查找</strong>的思想，平均运行时间为<code>$O(\log n)$</code>，最糟的情况下所需的时间为<code>$O(n)$</code>。在有序数组中查找时即便是最糟情况下所需的时间也只有<code>$O(\log n)$</code>，但这不意味着有序数组比二叉查找树更佳，因为二叉查找树的插入和删除操作的速度快的多：</p>
<p><img src="http://image.oldzhou.cn/FlF6aYs9sjSCCiJCpvBzZJ9C-WN-"></p>
<p>二叉树的查找的最大次数等同于二叉查找树的高度。</p>
<p>二叉查找树也有一些缺点：不能随机访问，并且如果二叉查找树处于失衡状态下，查找的性能会大打折扣，几乎变成了线性查找：</p>
<p><img src="http://image.oldzhou.cn/FiWlG9ksWIX1G_3GvJoiB8Ktmkxc"></p>
<p>如何解决二叉树多次插入新节点而导致的不平衡呢？可以使用红黑树来解决，红黑树（Red Black Tree）是一种自平衡的二叉查找树，除了符合二叉查找树的基本特征之外，还有一系列的附加特性，通过每次插入新节点后的处理（变色、反转）来保证自身符合红黑树的附加特性，实现了自平衡</p>
<p><img src="http://image.oldzhou.cn/Fn_k5y9H71yf44EpwYgcjm95SYIp"></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/31805309">知乎这篇文章</a>讲解二叉查找树和红黑树讲的很好，通俗易懂。</p>
<h3 id="反向索引"><a href="#反向索引" class="headerlink" title="反向索引"></a>反向索引</h3><p>搜索引擎的工作原理就是使用反向索引这种数据结构：一个散列表，将单词映射到包含它的页面</p>
<h3 id="傅里叶变换"><a href="#傅里叶变换" class="headerlink" title="傅里叶变换"></a>傅里叶变换</h3><p>（1）傅立叶级数</p>
<p>傅立叶级数实际上就是把<code>$f(x)$</code>看作是圆周运动的组合。只是<code>$x$</code>是不断变大的，而不是绕着圆变换的，所以就画出了函数曲线：</p>
<p><img src="http://image.oldzhou.cn/Fqtw8x2bLAZf3bInFWPOy-ZLZwd6"></p>
<p>不断增大的<code>$x$</code>就好像是时间流逝，永不回头，所以我们也称为“时域”。</p>
<p>时域是现实存在的，频域却是生造的了，理解起来更加抽象。但频域是傅立叶级数（变换）更本质的内容。</p>
<p>傅里叶技术的一个典型应用就是图像压缩，哪些基上的坐标值特别小，就可以丢掉，这样就可以压缩图像，JPG就是利用傅里叶进行图片压缩的</p>
<p>（2）傅里叶变换</p>
<p>傅立叶级数是基于周期函数的，如果将周期推广到<code>$\infty$</code>，那么也就变为了非周期函数，这就是傅里叶变换</p>
<p>这部分的内容可以参考<a target="_blank" rel="noopener" href="https://www.matongxue.com/madocs/473.html/">如何通俗地理解傅立叶变换？</a>和<a target="_blank" rel="noopener" href="https://www.matongxue.com/madocs/619.html">如何理解傅立叶级数公式？</a></p>
<h3 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h3><p>MapReduce是一种流行的分布式算法，可以通过流行的开源工具Apache Hadoop来是实现它。</p>
<blockquote>
<p>Hadoop是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储。Hadoop实现了一个分布式文件系统（Hadoop Distributed File System），简称HDFS。HDFS有高容错性的特点，并且设计用来部署在低廉的（low-cost）硬件上；而且它提供高吞吐量（high throughput）来访问应用程序的数据，适合那些有着超大数据集（large data set）的应用程序。HDFS放宽了（relax）POSIX的要求，可以以流的形式访问（streaming access）文件系统中的数据。</p>
<p>Hadoop的框架最核心的设计就是：HDFS和MapReduce。HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p>
</blockquote>
<p>分布式算法非常实用用于在短时间内完成海量工作，其中的MapReduce基于两个简单的历年：映射（map）函数和归并（reduce）函数</p>
<p>映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。映射函数是将一个数组转换为另一个数组。而归并函数的理念是将很多项归并为一项，将一个数组转换为一个函数</p>
<p>MapReduce是第一代计算引擎，Tez和Spark是第二代。MapReduce的设计，采用了很简化的计算模型，只有Map和Reduce两个计算过程（中间用Shuffle串联），用这个模型，已经可以处理大数据领域很大一部分问题了。</p>
<p>关于MapReduce的介绍可以看<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/094c5aab1fdb">这篇文章</a>。</p>
<h3 id="布隆过滤器和HyperLogLog"><a href="#布隆过滤器和HyperLogLog" class="headerlink" title="布隆过滤器和HyperLogLog"></a>布隆过滤器和HyperLogLog</h3><p>布隆过滤器是为了解决在海量数据中查找某个键是否存在的技术，它是一种概率性型数据结构，提供的答案有可能不对，但很可能是正确的。</p>
<p>判断网页以前是否已搜集，可以不适用散列表，而是用布隆过滤器，它的优点在于占用的存储空间少，非常适合于不要求答案绝对准确的情况。</p>
<p>关于布隆过滤器的原理可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43263751/">这篇文章</a>。</p>
<p>HyperLoglog是一种类似于布隆过滤器的算法。可以近似地计算集合中不同的元素数，提供不精确的去重计数，它也不能给出准确的答案，但是八九不离十，而占用的内存空间却少得多。关于HypoerLogLog的解释可以阅读<a target="_blank" rel="noopener" href="https://juejin.im/post/5c7900bf518825407c7eafd0">这篇文章</a>。</p>
<p>上面的这两种都是概率算法，都要求允许统计巨量数据面前的误差范围可以接受。</p>
<h3 id="SHA算法"><a href="#SHA算法" class="headerlink" title="SHA算法"></a>SHA算法</h3><p>SHA函数（secure hash algorightm）是一种安全散列算（也就是哈希算法），给定一个字符串，SHA返回其散列值。</p>
<p>有两种应用：</p>
<p>（1）比较文件</p>
<p>对于不同的字符串，SHA生成的散列值不同，可以利用SHA来判断两个文件是否相同，在比较超大型文件时很有用，可以计算文件的SHA散列值，再对结果进行比较。</p>
<p>（2）检查密码</p>
<p>SHA能在不知道原始字符串的情况下进行比较，进行密码登陆时，不会直接存储密码，而是比较散列值。网站保存的不是原始密码，而是密码的散列值。</p>
<p>SHA散列算法是单项的，可以根据字符串计算散列值，但是无法根据散列值推出原始字符串。</p>
<p>SHA实际上是一系列散发：SHA-0&#x2F;SHA-1&#x2F;SHA-2&#x2F;SHA-3，SHA-0和SHA-1被发现存在一些缺陷，应该使用SHA-2和SHA-3来计算密码散列值，最安全的散列函数是bcrypt。</p>
<p>关于各种散列算法的介绍可以阅读<a target="_blank" rel="noopener" href="https://www.zhihu.com/appview/p/37165658">这篇文章</a>。</p>
<h3 id="局部明暗的散列算法"><a href="#局部明暗的散列算法" class="headerlink" title="局部明暗的散列算法"></a>局部明暗的散列算法</h3><p>SHA算法是局部不敏感的，对一个字符串，如果只改动了其中一个字符，得到的两个散列值是完全不同的，这就让攻击者无法通过比较散列值是否类似来破解密码。</p>
<p>如果希望散列函数是局部明暗的，可以使用Simhash，对字符串进行细微的修改，Simhash生成的散列值也只存在细微的差别。这就可以通过比较散列值来比较两个字符串的相似程度，应用：</p>
<ul>
<li>Google来判断网页是否被收集</li>
<li>论文查重&#x2F;资源查重</li>
</ul>
<p>需要检查两项内容的相似程度时，可以使用Simhash。</p>
<h3 id="Diffie-Hellman密钥交换"><a href="#Diffie-Hellman密钥交换" class="headerlink" title="Diffie-Hellman密钥交换"></a>Diffie-Hellman密钥交换</h3><p>Diffie-Hellman密钥交换解决了两个问题：</p>
<ol>
<li>双方无序知道加密算法，不必会面协商使用的加密算法</li>
<li>破解加密非常困难</li>
</ol>
<p>使用了两个密钥：公钥和私钥。它的替代者是RSA，被广泛使用。</p>
<h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><p>线性规划用于在给定约束条件下最大限度的改善指定的指标。</p>
<p>所有的图算法都可以使用线性规划来实现，图问题知识线性规划的一个子集。</p>
<p>线性规划使用Simplex算法。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/08/19/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/07%20%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%98/%E9%9B%B6%E6%95%A3%E4%B8%93%E9%A2%9837%20%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%BC%82%E5%B8%B8%E7%9B%91%E6%8E%A7/" rel="prev" title="零散专题37 前端代码异常监控">
                  <i class="fa fa-chevron-left"></i> 零散专题37 前端代码异常监控
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/09/17/01%20%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B0/04%20Vue/04%20Vue%20Router/VueRouter02%20%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB/" rel="next" title="VueRouter02 导航守卫">
                  VueRouter02 导航守卫 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">多啦大薯片</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/next-boot.js"></script>

  




  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"duola8789/duola8789.github.io","issue_term":"pathname","theme":"github-light"}</script>
<script src="/js/third-party/comments/utterances.js"></script>

</body>
</html>
